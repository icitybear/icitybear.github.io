---
title: "Go包-sync.Cond条件变量" #标题
date: 2025-08-18T18:30:51+08:00 #创建时间
lastmod: 2025-08-18T18:30:51+08:00 #更新时间
author: ["citybear"] #作者
categories: # 没有分类界面可以不填写
- tech
tags: # 标签
- go包
- go并发编程
- go源码
keywords: 
- 
description: "" #描述 每个文章内容前面的展示描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true #是否展示评论 有自带的扩展成twikoo
showToc: true # 显示目录 文章侧边栏toc目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
    image: "" #图片路径：posts/tech/文章1/picture.png
    caption: "" #图片底部描述
    alt: ""
    relative: false

# reward: true # 打赏
mermaid: true #自己加的是否开启mermaid
---
# 概念
条件变量（Condition Variable）是一种线程间通信的机制，用于等待某个条件的发生。当一个线程等待某个条件时，它会阻塞并释放锁，直到另一个线程发出信号通知该条件已经满足，该线程才会被唤醒并重新获得锁。

- <font color="red">无需通道携带数据，只要一个唤醒信号，理解成简化多轮go抢锁过程</font>

func (c Cond) Wait()阻塞等待条件变量满足，释放已掌握的互斥锁相当于cond.L.Unlock()。 注意：两步为一个原子操作。

当被唤醒，Wait()函数返回时，解除阻塞并重新获取互斥锁。相当于cond.L.Lock() func (c *Cond) Signal()：

单发通知，给一个正等待（阻塞）在该条件变量上的goroutine（线程）发送通知【一般都使用这个】

# 应用场景
<font color="red">sync 包的 Cond 类型</font>, 用来实现:
- 可以和互斥锁或读写锁（以下统称互斥锁）组合使用，用来<font color="red">协调想要访问共享资源的线程</font>,实现多个 Go 协程之间的通信
- 主要作用并不是保证在同一时刻仅有一个线程访问某一个共享资源，而是<font color="red">**在对应的共享资源状态发生变化时，通知其它因此而阻塞的线程**</font>

## 基础使用
``` go
var cond sync.Cond      //定义全局条件变量
func producer(out chan<-int,idx int){
	for {
		//先加锁
		cond.L.Lock()
		//判断缓冲区是否满
		for len(out) == cap(out){
			cond.Wait()    //1,zuse 2 shifangsuo 3 huanxingjiasuo
		}
		num:= rand.Intn(999)
		out<- num
		fmt.Println("生产者:",idx,"生产：", num)
		//访问公共区结束，并且打印结束，解锁
		cond.L.Unlock()
		//唤醒对端
		cond.Signal()
		time.Sleep(time.Millisecond*300)
	}
}

func consumer(in <-chan int,idx int){
	for {
		cond.L.Lock()
		//判断缓冲区是否为空
		for len(in)== 0{
			cond.Wait()
		}
		num := <-in
		 fmt.Println("消费者:",idx,"消费：",num)
		//访问公共区结束后，解锁
		cond.L.Unlock()  //锁的力度越小越好
		cond.Signal()
		 time.Sleep(time.Millisecond*300)
	}
}

func main(){
	rand.Seed(time.Now().UnixNano())
	product := make(chan int,5)
	//指定条件变量 使用的锁
	cond.L = new(sync.Mutex)//互斥锁初值为0，是未加锁状态

	for i:=0;i<5;i++{
		go producer(product,i+1)

	}
	for i:=0;i<5;i++{
		go consumer(product,i+1)
	}
	for{
		;
	}
}
```

## 案例：读写器
假设我们有一个读取器和一个写入器，读取器必须依赖写入器对缓冲区进行数据写入后，才可以从缓冲区中读取数据，写入器每次完成写入数据后，都需要通过某种通知机制通知处于阻塞状态的读取器，告诉它可以对数据进行访问
``` go 
// 数据 bucket
type DataBucket struct {
	buffer *bytes.Buffer //缓冲区
	mutex  *sync.RWMutex //互斥锁
	cond   *sync.Cond    //条件变量
}

func NewDataBucket() *DataBucket {
	buf := make([]byte, 0)
	db := &DataBucket{
		buffer: bytes.NewBuffer(buf),
		mutex:  new(sync.RWMutex),
	}
	db.cond = sync.NewCond(db.mutex.RLocker())
	return db
}

// 读取器
func (db *DataBucket) Read(i int) {
	db.mutex.RLock()         // 打开读锁
	defer db.mutex.RUnlock() // 结束后释放读锁
	var data []byte
	var d byte
	var err error
	for {
		// 每次读取一个字节
		if d, err = db.buffer.ReadByte(); err != nil {
			if err == io.EOF { // 缓冲区数据为空时执行
				if string(data) != "" { // data 不为空，则打印它
					fmt.Printf("reader-%d: %s\n", i, data)
				}
				db.cond.Wait()  // 缓冲区为空，通过 Wait 方法等待通知，进入阻塞状态
				data = data[:0] // 读取完毕后 将 data 清空
				continue
			}
		}
		data = append(data, d) // 将读取到的数据添加到 data 中
	}
}

// 写入器
func (db *DataBucket) Put(d []byte) (int, error) {
	db.mutex.Lock()         // 打开写锁
	defer db.mutex.Unlock() // 结束后释放写锁
	// 写入一个数据块
	n, err := db.buffer.Write(d)
	db.cond.Signal() // 写入数据后通过 Signal 通知处于阻塞状态的读取器
	// 通知多个读取器的时候多个协程
	// db.cond.Broadcast()// 写入数据后通过 Broadcast 通知处于阻塞状态的读取器
	return n, err
}

func TestSingle(t *testing.T) {
	db := NewDataBucket()
	go db.Read(1) // 开启读取器协程
	go func(i int) {
		d := fmt.Sprintf("data-%d", i)
		db.Put([]byte(d)) // 写入数据到缓冲区
	}(1) // 开启写入器协程
	time.Sleep(100 * time.Millisecond)

}

// 输出
// reader-1: data-1

// 通知多个读取器的时候 用Broadcast
func TestDouble(t *testing.T) {
	db := NewDataBucket()
	for i := 1; i < 3; i++ { // 启动多个读取器
		go db.Read(i)
	}
	for j := 0; j < 10; j++ { // 启动多个写入器
		go func(i int) {
			d := fmt.Sprintf("data-%d", i)
			db.Put([]byte(d)) // 写入数据到缓冲区
		}(j)
		time.Sleep(100 * time.Millisecond) // 每次启动一个写入器暂停100ms，让读取器阻塞
	}
}

// 输出
// reader-1: data-0
// reader-1: data-1
// reader-2: data-2
// reader-1: data-3
// reader-2: data-4
// reader-1: data-5
// reader-2: data-6
// reader-1: data-7
// reader-2: data-8
// reader-1: data-9

```

- 读写互斥锁，在读取器里面使用读锁，在写入器里面使用写锁，并且通过 defer 语句释放锁，然后<font color="red">在锁保护的情况下，通过条件变量协调读写线程</font>：
1. 在读线程中，当缓冲区为空的时候，通过 db.cond.Wait() 阻塞读线程；
2. 在写线程中，当缓冲区写入数据的时候通过 db.cond.Signal() 通知读线程继续读取数据。通知多个阻塞线程需要使用 db.cond.Broadcast()

# 源码
``` go 
type Cond struct {
  noCopy noCopy
​
  // L is held while observing or changing the condition
  L Locker
​
  notify  notifyList
  checker copyChecker
}
// 初始化 NewCond
// 等待通知
func (c *Cond) Wait() {
  c.checker.check()
  t := runtime_notifyListAdd(&c.notify)
  c.L.Unlock()
  runtime_notifyListWait(&c.notify, t)
  c.L.Lock()  
}
​
// 单发通知
func (c *Cond) Signal() {
  c.checker.check()
  runtime_notifyListNotifyOne(&c.notify)  
}
​
// 广播通知
func (c *Cond) Broadcast() {
  c.checker.check()
  runtime_notifyListNotifyAll(&c.notify)  
}
```

- 通过 sync.NewCond 返回对应的条件变量实例，初始化的时候需要传入互斥锁(读写锁继承有互斥锁)，<font color="red">该互斥锁实例会赋值给 sync.Cond 的 L 属性</font>
- 通知单个阻塞线程用 Signal 方法，通知多个阻塞线程需要使用 Broadcast 方法

需要某种变量状态的 goroutine A 将会等待（Wait）在那里，当某个时刻变量状态改变时，负责通知的 goroutine B 会通过对条件变量通知的方式（Broadcast/Signal）来通知处于等待条件变量的 goroutine A，这样就可以在共享内存中<font color="red">实现类似「消息通知」的同步机制</font>
