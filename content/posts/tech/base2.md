---
title: "1.0-并发编程从多进程、多线程到协程" #标题
date: 2023-07-17T23:58:50+08:00 #创建时间
lastmod: 2023-07-17T23:58:50+08:00 #更新时间
author: ["citybear"] #作者
categories: # 没有分类界面可以不填写
- tech
tags: # 标签
- 基础
- go并发编程
keywords: 
- 
description: "" #描述 每个文章内容前面的展示描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true #是否展示评论 有自带的扩展成twikoo
showToc: true # 显示目录 文章侧边栏toc目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
    image: "" #图片路径：posts/tech/文章1/picture.png
    caption: "" #图片底部描述
    alt: ""
    relative: false

# reward: true # 打赏
mermaid: true #自己加的是否开启mermaid
---

# 为什么需要并发编程

- 串行，即代码按照顺序一行一行执行，当遇到某个耗时的 IO 操作时，比如发送邮件、查询数据库等，要等到该 IO 操作完成后才能继续执行下一行代码
- 并行
  - **从整个操作系统层面来说，多个任务是可以并发执行的，因为 CPU 本身通常是多核的(并行)，而且即使是单核 CPU，也可以通过时间分片的方式在多个进程/线程之间切换执行（并发）**
  - 从用户角度来说，就好像它们在「同时执行」一样，比如说，<font color="red">当程序执行到 IO 操作时，我们可以挂起这个任务</font>，把 CPU 时间片出让给其他任务，然后当这个 IO 操作完成时，通知 CPU 恢复后续代码的执行
  - <font color="red">cpu进行调度</font>,并发编程可以最大限度榨取 CPU 的价值，提高程序的执行效率和性能。
![](demo.png)

# 并发与并行的区别
- **并行**侧重于通过CPU多核能力同时处理多个任务，每个任务分配给单独处理器执行，<font color="red">同一时间点，任务是同时执行的</font>；而**并发**则侧重于在单核CPU中，<font color="red">通过CPU时间分片实现任务的交替执行，由于CPU上下文切换很快</font>，给用户的感觉和多个任务同时执行没有什么区别

- 并行需要多核支持，并且不同内核之间资源不共享，会导致系统资源开销很大，任务之间的通信非常困难，<font color="red">并发可以在单核内完成，系统开销更小，任务间通信更方便</font>
- <font color="red">go是基于并发, 而非并行</font>


# 并发编程的常见实现
1. **多进程**。操作系统层面进行并发的基本模式,开销最大的模式。比如 <font color="red">PHP-FPM</font>，它会有专门的主进程负责网络端口的监听和连接管理，还会有多个工作进程负责具体的请求处理。这种方法的**好处在于简单、进程间互不影响，坏处在于系统开销大**，因为所有的<font color="red">进程都是由内核管理</font>的，而且不同进程的数据也是相互隔离的。
[php的进程-有道云笔记](https://note.youdao.com/s/827xrFbu)
2. **多线程**。属于系统层面的并发模式, 线程比进程轻量级，<font color="red">线程间可以共享数据，开销要比多进程小很多，但是依旧比较大，且在高并发模式下，效率会有影响</font>
   - **基于回调的非阻塞/异步 IO**. <font color="red">通过事件驱动的方式使用异步 IO</font>，在这种模式下，**一个线程可以维护多个 Socket 连接**，从而降低系统开销，保持服务器的持续运转,比如 <font color="red">node.js与nginx</font>,涉及到直接调用操作系统底层的库函数（select、epoll、libevent 等）来实现，非常复杂

   - **协程**, 用户态线程，轻量级的线程，不需要操作系统来进行抢占式调度，系统开销极小，可以有效提高线程的任务并发性，避免多线程的缺点. <font color="red">需要语言级别的支持,调度器支持</font>。 扩展库的方式：<font color="red">PHP 的 Swoole 扩展</font>也是参考了 Go 协程的实现将其搬到 PHP 中,但用**扩展库的方式支持的功能通常并不完整，比如仅仅提供轻量级线程的创建、销毁与切换等能力。如果在这样的轻量级线程中调用一个同步 IO 操作，比如网络通信、本地文件读写，都会阻塞其他的并发执行轻量级线程**

由于多进程比较消耗系统资源，且进程间数据隔离，CPU 切换成本高，因此，<font color="red">传统并发编程多以多线程为主(java)</font>, go使用协程

追求性能，通常不会直接通过事件驱动的异步 IO 来实现并发编程一样，因为这涉及到直接调用操作系统底层的库函数（select、epoll、libevent 等）来实现，非常复杂。

# 并发编程
- 串行编程中，事务具有确定性，比如我们想好了123，然后按照这个顺序来编写代码，代码会严格按照这个设定的顺序执行，即使在某一个步骤阻塞了，也会一直等待阻塞代码执行完毕，再去执行下一步的代码。
- 多线程并发模式，<font color="red">有不确定性,程序变得不可控</font>
  - 不知道主线程执行完毕的时候，新线程是否执行完毕了，如果主线程执行完毕退出应用，可能导致新线程的中断，
  - 或者我们在第3步的时候依赖第2步的某个返回结果，我们不知道啥时候能够返回这个结果，如果第2、3步有相互依赖的变量，甚至可能出现死锁（死循环）
  - 以及我们如何在主线程中获取新线程的异常和错误信息并进行相应的处理

## 共享内存系统，消息传递系统
- 将线程加共享内存的方式称为「共享内存系统」,「消息传递系统」解决共享内存系统存在的问题(加锁来避免死锁或资源竞争，竞态条件)
### 消息传递系统
- Communicating Sequential Processes 中提出的，在 CSP 系统中，所有的并发操作都是通过独立线程以异步运行的方式来实现的。这些线程必须通过在彼此之间发送消息，从而向另一个线程请求信息或者将信息提供给另一个线程。

1. 需要通过线程间通信来告知不同线程目前各自运行的状态和结果，以便使程序可控。**<font color="red">常见的并发通信模型有两种：共享内存和消息传递(比如通道)</font>**
  - 通过共享内存的方式，即<font color="red">在不同线程中操作的是同一个内存地址上存储的值</font>, 保证共享内存的有效性， (一个重要的、不可忽视的要素就是<font color="red">如何确保不同协程同时访问同一资源的数据竞争和并发安全问题</font>)
    - 比如加锁,原子操作等来避资源竞争等
  - <font color="red">从消息通道读取数据并处理</font>

- 由于需要执行状态复制操作，所以大多数消息传递的实现在性能上并不优越，但线程中的状态管理工作则会变得更加简单

### 线程与协程的对比。区别
- 轻量级,<font color="red">(用户态的轻量级线程)</font>,可以轻松创建上百万个协程而不会导致系统资源衰竭，而线程和进程通常最多也不能超过 1 万个（C10K问题）。
- goroutine。Go 语言标准库提供的所有系统调用操作（当然也包括所有同步 IO 操作），都有协程的身影
- <font color="red">协程间的切换管理不依赖于**系统的线程和进程**，也不依赖于 CPU 的核心数量</font>
- Go的协程 会共享内存

# 利用多核 CPU 实现并行计算（go语言 CPU 密集型计算）

多进程、多线程以及协程显然都是属于「并发」范畴的，可以实现程序的并发执行，至于是否支持「并行」，则要看程序运行系统是否是多核，以及编写程序的语言是否可以利用 CPU 的多核特性

真正的并行还得需要GPU?

- Go 语言中通过协程有效利用「多核」实现程序的「并行」执行
-  <font color="red">根据系统 CPU 核心数量来**分配等值的子协程数**,让所有协程分配到每个内核去并行执行</font>
  - 物理 CPU 和逻辑 CPU 核心数 mac 命令行 sysctl hw.physicalcpu sysctl hw.logicalcpu
  - 物理 CPU 核心数指的是真正插在物理插槽上 CPU 的核心数，逻辑 CPU 核心数指的是结合 CPU 多核以及超线程技术得到的 CPU 核心数，<font color="red">最终核心数以逻辑 CPU 核心数为准。</font>
- <font color="red">Go 语言中通过调用 runtime.NumCPU() 方法获取 CPU 核心数, runtime.GOMAXPROCS(cpus)设置使用的最大核心数</font>
- 每个子协程计算分给它的那部分计算任务，最后将不同子协程的计算结果再做一次累加，这样就可以得到所有数据的计算总和
- 多核比单核整体运行速度快了N倍左右, 在<font color="red"> CPU 密集型计算</font>中带来的性能提升还是非常显著的,对于 IO 密集型计算可能没有这么显著，甚至有可能比单核低，因为 CPU 核心之间的切换也是需要时间成本的

``` go 
package main

import (
    "fmt"
    "runtime"
    "time"
)

func sum(seq int, ch chan int) {
    defer close(ch)
    sum := 0
    for i := 1; i <= 10000000; i++ {
        sum += i
    }
    fmt.Printf("子协程%d运算结果:%d\n", seq, sum)
    ch <- sum
}

func main()  {
    // 启动时间
    start := time.Now()
    // 最大 CPU 核心数
    cpus := runtime.NumCPU()
    // runtime.GOMAXPROCS() 方法设置程序运行时可以使用的最大核心数
    runtime.GOMAXPROCS(cpus)
    // 后续 传入的 CPU 核心数为 1 对比消耗时间

    // 初始化通道数组 数量和 CPU 核心数保持一致(每个子协程用到)
    chs := make([]chan int, cpus)
    for i := 0; i < len(chs); i++ {
        chs[i] = make(chan int, 1)
        go sum(i, chs[i])
    }
    sum := 0
    // 遍历通道切片
    for _, ch := range chs {
        // 接收每个通道数据
        res := <- ch
        sum += res
    }
    // 结束时间
    end := time.Now()
    // 打印耗时
    fmt.Printf("最终运算结果: %d, 执行耗时(s): %f\n", sum, end.Sub(start).Seconds())
}
```