---
title: "5.0-goé”™è¯¯å¤„ç†errorä¸defer,panic,recover" #æ ‡é¢˜
date: 2023-07-16T19:44:10+08:00 #åˆ›å»ºæ—¶é—´
lastmod: 2023-07-16T19:44:10+08:00 #æ›´æ–°æ—¶é—´
author: ["citybear"] #ä½œè€…
categories: # æ²¡æœ‰åˆ†ç±»ç•Œé¢å¯ä»¥ä¸å¡«å†™
- tech
tags: # æ ‡ç­¾
- goé¢å‘å¯¹è±¡
- goæºç 
keywords: 
- 
description: "" #æè¿° æ¯ä¸ªæ–‡ç« å†…å®¹å‰é¢çš„å±•ç¤ºæè¿°
weight: # è¾“å…¥1å¯ä»¥é¡¶ç½®æ–‡ç« ï¼Œç”¨æ¥ç»™æ–‡ç« å±•ç¤ºæ’åºï¼Œä¸å¡«å°±é»˜è®¤æŒ‰æ—¶é—´æ’åº
slug: ""
draft: false # æ˜¯å¦ä¸ºè‰ç¨¿
comments: true #æ˜¯å¦å±•ç¤ºè¯„è®º æœ‰è‡ªå¸¦çš„æ‰©å±•æˆtwikoo
showToc: true # æ˜¾ç¤ºç›®å½• æ–‡ç« ä¾§è¾¹æ tocç›®å½•
TocOpen: true # è‡ªåŠ¨å±•å¼€ç›®å½•
hidemeta: false # æ˜¯å¦éšè—æ–‡ç« çš„å…ƒä¿¡æ¯ï¼Œå¦‚å‘å¸ƒæ—¥æœŸã€ä½œè€…ç­‰
disableShare: true # åº•éƒ¨ä¸æ˜¾ç¤ºåˆ†äº«æ 
showbreadcrumbs: true #é¡¶éƒ¨æ˜¾ç¤ºå½“å‰è·¯å¾„
cover:
    image: "" #å›¾ç‰‡è·¯å¾„ï¼šposts/tech/æ–‡ç« 1/picture.png
    caption: "" #å›¾ç‰‡åº•éƒ¨æè¿°
    alt: ""
    relative: false

# reward: true # æ‰“èµ
mermaid: true #è‡ªå·±åŠ çš„æ˜¯å¦å¼€å¯mermaid
---


![alt text](image.png)
# å¤šè¿”å›å€¼
å…¶ä»–è¯­è¨€ä¸­ï¼Œå‡½æ•°é€šå¸¸é€šè¿‡è¿”å›ç‰¹æ®Šå€¼å¦‚-1ã€nullã€""ç­‰æ¥è¡¨ç¤ºé”™è¯¯æˆ–ç¼ºå¤±çš„ç»“æœã€‚è¿™è¢«ç§°ä¸ºâ€œå¸¦å†…é”™è¯¯â€ï¼ˆin-band errorsï¼‰ã€‚ä½¿ç”¨ in-band é”™è¯¯çš„ä¸»è¦é—®é¢˜æ˜¯ï¼Œéœ€è¦è°ƒç”¨è€…è®°ä½æ¯æ¬¡éƒ½è¦æ£€æŸ¥è¿”å›çš„ç‰¹æ®Šå€¼ã€‚ä½†è¿™æ˜¯...éå¸¸å®¹æ˜“å‡ºé”™çš„ã€‚

- goæ”¯æŒå¤šè¿”å›å€¼ï¼Œå¯ä»¥æ˜ç¡®å¤„ç†è¿”å›çš„é”™è¯¯
# Go æ ‡å‡†é”™è¯¯åŒ…erroræ¥å£
- Go è¯­è¨€ä¸ºé”™è¯¯å¤„ç†å®šä¹‰äº†ä¸€ä¸ªæ ‡å‡†æ¨¡å¼ï¼Œå³ <font color="red">error æ¥å£</font>
- é€šè¿‡<font color="red">**Go æ ‡å‡†é”™è¯¯åŒ… errors**</font> æä¾›çš„ New() æ–¹æ³•å¿«é€Ÿåˆ›å»ºä¸€ä¸ª<font color="red"> error ç±»å‹çš„é”™è¯¯å®ä¾‹</font>
- fmt.Println(err), æ‰“å°é”™è¯¯ä¿¡æ¯æ—¶ï¼Œç›´æ¥ä¼ å…¥äº† err å¯¹è±¡å®ä¾‹ï¼Œå› ä¸º Go åº•å±‚ä¼š<font color="red">è‡ªåŠ¨è°ƒç”¨ err å®ä¾‹ä¸Šçš„ Error() æ–¹æ³•è¿”å›é”™è¯¯ä¿¡æ¯å¹¶å°†å…¶æ‰“å°å‡ºæ¥ï¼Œå°±åƒæ™®é€šç±»çš„ String() æ–¹æ³•ä¸€æ ·ã€‚</font>

``` go
type error interface {
  Error() string
}
// Go æä¾›äº†ä¸€ä¸ªé»˜è®¤å®ç° é»˜è®¤errors.Newçš„è¿”å›ç±»å‹errors.errorString
type errorString struct {
  s string
}

func (e *errorString) Error() string {
  return e.s
}
```
- åº•å±‚å°±æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ç»“æ„ä½“ errorString ï¼ˆerrors.errorStringï¼‰

``` go
// ä¸€èˆ¬è¿™æ ·è¿”å›é”™è¯¯ è¿”å›errorç±»å‹
func Foo(param int) (n int, err error) { 
    // ...
    // err = errors.New("åªæ”¯æŒéè´Ÿæ•´æ•°ç›¸åŠ ")
}
n, err := Foo(0)

if err != nil { 
    // é”™è¯¯å¤„ç† 
} else {
    // ä½¿ç”¨è¿”å›å€¼ n 
}
```

# æ›´å¤æ‚çš„é”™è¯¯ç±»å‹

1. ç³»ç»Ÿå†…ç½®é”™è¯¯ç±»å‹
Go è¯­è¨€å†…ç½®çš„å¾ˆå¤šåŒ…è¿˜å°è£…äº†æ›´å¤æ‚çš„é”™è¯¯ç±»å‹ã€‚æ‰©å±•äº†ç‰¹å®šçš„ä¿¡æ¯,å…·ä½“æŸä¸ªé”™è¯¯åªè¦å®ç° Error()æ¥å£

- ä»¥ os åŒ…ä¸ºä¾‹ï¼Œè¿™ä¸ªåŒ…ä¸»è¦è´Ÿè´£ä¸æ“ä½œç³»ç»Ÿæ‰“äº¤é“ï¼Œæ‰€ä»¥æä¾›äº† LinkErrorã€PathErrorã€SyscallError è¿™äº›<font color="red">å®ç°äº† error æ¥å£</font>çš„é”™è¯¯ç±»å‹ï¼Œä»¥ PathError ä¸ºä¾‹
``` go
type PathError struct {
    Op   string
    Path string
    Err  error
}

// é”™è¯¯ç±»å‹é™¤äº†ç»„åˆ error æ¥å£å®ç° Error() æ–¹æ³•å¤–ï¼Œ
// è¿˜æä¾›äº†é¢å¤–çš„æ“ä½œç±»å‹å­—æ®µ Op å’Œæ–‡ä»¶è·¯å¾„å­—æ®µ Path ä»¥ä¸°å¯Œé”™è¯¯ä¿¡æ¯
func (e *PathError) Error() string { 
    return e.Op + " " + e.Path + ": " + e.Err.Error() 
}

// è·å–æŒ‡å®šè·¯å¾„æ–‡ä»¶ä¿¡æ¯ï¼Œå¯¹åº”ç±»å‹æ˜¯ FileInfo
fi, err := os.Stat("test.txt") 
if err != nil {
    switch err.(type) {
    // å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ™è¿”å› PathError ç±»å‹é”™è¯¯    
    case *os.PathError:
        // do something
    case *os.LinkError:
        // dome something
    case *os.SyscallError:
        // dome something
    case *exec.Error:
        // dome something
    }
} else {
    // ...
}
```

2. è‡ªå®šä¹‰é”™è¯¯ç±»å‹
- è‡ªå®šä¹‰é”™è¯¯å€¼ï¼Œåº”ä»¥Errå¼€å¤´ï¼›è‡ªå®šä¹‰çš„é”™è¯¯ç±»å‹ï¼Œåº”è¯¥ä»¥Errorç»“å°¾

ä»¿ç…§ PathError çš„å®ç°è‡ªå®šä¹‰ä¸€äº›å¤æ‚çš„é”™è¯¯ç±»å‹ï¼Œ**åªéœ€è¦<font color="red">ç»„åˆ error æ¥å£å¹¶å®ç° Error() æ–¹æ³•</font>å³å¯ï¼Œç„¶åæŒ‰ç…§è‡ªå·±çš„éœ€è¦ä¸ºè‡ªå®šä¹‰ç±»å‹æ·»åŠ ä¸€äº›å±æ€§å­—æ®µ**

``` go
// é”™è¯¯è‹¥è®¾ç½®æˆå¯å¯¼å‡ºï¼Œæ„å‘³ç€ä½¿ç”¨åŒ…çš„äººéœ€è¦è¯†åˆ«å¹¶å¤„ç†è¿™ä¸ªé”™è¯¯ï¼Œåç»­ä¸å¯éšæ„æ›´æ”¹

var ErrExample = errors.New("ç¤ºä¾‹é”™è¯¯")

type CustomError struct {
	Msg string
}

func (e *CustomError) Error() string {
	return e.Msg
}

// æŒ‡é’ˆæ¥æ”¶è€…å®ç° Error
type PtrError struct {
	Msg string
}

func (e *PtrError) Error() string {
	return e.Msg
}

// å€¼æ¥æ”¶è€…å®ç° Error
type ValError struct {
	Msg string
}

func (e ValError) Error() string {
	return e.Msg
}
```


# wrapError å®˜æ–¹åº“
- wrapErroræœ¬è´¨ä¹Ÿæ˜¯ä¸€ä¸ª error ï¼Œå¹¶å£°æ˜äº†ä¸€ä¸ª Unwrap æ–¹æ³•ç”¨äºæ‹†åŒ…è£…ã€‚ å¯ä»¥åµŒå¥—æ„å»ºé”™è¯¯é“¾
``` go
type wrapError struct {
  msg string
  err error
}

func (e *wrapError) Error() string {
  return e.msg
}

func (e *wrapError) Unwrap() error {
  return e.err
}
```

## fmt.Errorfä¸fmt.wrapErrorç±»å‹
1. fmt.Errorf æ ¼å¼åŒ–æ—¶ä½¿ç”¨ %w  
2. fmt.Errorf ç”¨äº†å ä½ç¬¦ %w ä¹‹ååˆ›å»ºçš„å°±æ˜¯ fmt.wrapError ç±»å‹
3.  %s åˆ›å»ºçš„å°±æ˜¯ errorString ç±»å‹, å¦‚æœæ˜¯%vä¹Ÿæ˜¯
4. 1.20å¼•å…¥ errors.Join ä»£æ›¿fmt.Errorf

``` go
func TestWrap(t *testing.T) {
	errA := errors.New("é”™è¯¯A")
	errB := fmt.Errorf("é”™è¯¯B: %w", errA)
	errC := fmt.Errorf("é”™è¯¯C: %w", errB)

	spew.Printf("errA: %+#v\nerrB: %+#v\nerrC: %+#v\n", errA, errB, errC)
}

// errA: (*errors.errorString)(0x14000066b50)é”™è¯¯A
// errB: (*fmt.wrapError)(0x14000070220)é”™è¯¯B: é”™è¯¯A
// errC: (*fmt.wrapError)(0x14000070240)é”™è¯¯C: é”™è¯¯B: é”™è¯¯A

```
- fmt.Errorf å¿…é¡»äº%wé…åˆä½¿ç”¨
``` go
func TestWrap(t *testing.T) {
	err := redis.Nil
	if errors.Is(err, redis.Nil) {
		println("err is redis.Nil")
	}
	// err3 := fmt.Errorf("wrap err3: %v", err) // err not is redis.Nil
	err3 := fmt.Errorf("wrap err3: %w", err) // err is redis.Nil
	if errors.Is(err3, redis.Nil) {
		println("err is redis.Nil")
	} else {
		println("err not is redis.Nil")
	}
}
```

### fmt.Errorf æ–¹æ³•çš„æºç 
``` go
func Errorf(format string, a ...any) error {
  p := newPrinter()
  p.wrapErrs = true
  p.doPrintf(format, a) //  è°ƒç”¨åï¼Œå¦‚æœåŒ…å« %w å ä½ç¬¦åˆ™ä¼šå…ˆåˆ›å»ºå†…å±‚çš„ error ï¼Œèµ‹å€¼ç»™ p.wrappedErr ï¼Œä»è€Œè§¦å‘ wrapError çš„åˆ›å»ºé€»è¾‘
  s := string(p.buf)
  var err error
  if p.wrappedErr == nil {
   err = errors.New(s)
  } else {
   err = &wrapError{s, p.wrappedErr}
  }
  p.free()
  return err
}

func (p *pp) handleMethods(verb rune) (handled bool) {
	if p.erroring {
		return
	}
    // handleMethods æ—¶ç‰¹æ®Šå¤„ç† w, ä½¿ç”¨ wrapError å°è£…
	if verb == 'w' {
		err, ok := p.arg.(error)
		if !ok || !p.wrapErrs || p.wrappedErr != nil {
			p.wrappedErr = nil
			p.wrapErrs = false
			p.badVerb(verb)
			return true
		}
		p.wrappedErr = err
		verb = 'v'
	}
  ......
}
```
### ä½¿ç”¨wrapErroræ„å»ºé”™è¯¯é“¾
- é€šè¿‡ fmt.Errorf æ–¹æ³•é…åˆ %w å ä½ç¬¦åˆ›å»ºåµŒå¥—ç±»å‹çš„ wrapError
- Unwrapçš„æ•ˆæœ
- go 1.20ç‰ˆæœ¬åä½¿ç”¨join
``` go
func TestUnwrap(t *testing.T) {
	errA := errors.New("é”™è¯¯A")
	errB := fmt.Errorf("é”™è¯¯B: %w", errA)
	errC := fmt.Errorf("é”™è¯¯C: %w", errB) // å¯¹åº”å‡½æ•°è¿”å›çš„errå¯ä»¥é€šè¿‡fmt.Errorfå°è£…

	spew.Printf("errA: %+#v\nerrA Unwrapå: %+#v\n", errA, errors.Unwrap(errA))
	fmt.Println("---------------------------------------")
	spew.Printf("errB: %+#v\nerrB Unwrapå: %+#v\n", errB, errors.Unwrap(errB))
	fmt.Println("---------------------------------------")
	spew.Printf("errC: %+#v\nerrC Unwrapå: %+#v\nerrCä¸¤æ¬¡Unwrapå: %+#v\n", errC, errors.Unwrap(errC), errors.Unwrap(errors.Unwrap(errC)))
}

// errA: (*errors.errorString)(0x14000066b60)é”™è¯¯A
// errA Unwrapå: (interface {})<nil>
// ---------------------------------------
// errB: (*fmt.wrapError)(0x14000070220)é”™è¯¯B: é”™è¯¯A
// errB Unwrapå: (*errors.errorString)(0x14000066b60)é”™è¯¯A
// ---------------------------------------
// errC: (*fmt.wrapError)(0x14000070240)é”™è¯¯C: é”™è¯¯B: é”™è¯¯A
// errC Unwrapå: (*fmt.wrapError)(0x14000070220)é”™è¯¯B: é”™è¯¯A
// errCä¸¤æ¬¡Unwrapå: (*errors.errorString)(0x14000066b60)é”™è¯¯A
```
è¦ä¹ˆè¿”å›é”™è¯¯å€¼ï¼Œè¦ä¹ˆè¾“å‡ºæ—¥å¿—ã€‚æ¯ä¸ªå‡½æ•°ä¸­ä½¿ç”¨fmt.Errorf +%wå°†é”™è¯¯åŒ…è£…ä¸ºä¸€ä¸ªwrapped errorï¼Œå¹¶å°†å‰ä¸€å±‚çš„é”™è¯¯ä½œä¸ºå‚æ•°ä¼ é€’ã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼Œæˆ‘ä»¬æ„å»ºäº†ä¸€ä¸ªé”™è¯¯é“¾ï¼Œå…¶ä¸­æ¯ä¸ªé”™è¯¯éƒ½åŒ…å«äº†ä¹‹å‰å‘ç”Ÿçš„é”™è¯¯ä¸Šä¸‹æ–‡ã€‚

## errors.Iså’Œerrors.As
- å®˜æ–¹ä¸æ¨èä½¿ç”¨ error == xxx
- **<font color="red">æ€»çš„æ¥è¯´ï¼Œerrors.Iså‡½æ•°ç”¨äºåˆ¤æ–­é”™è¯¯æ˜¯å¦ä¸ç»™å®šç±»å‹åŒ¹é…ï¼Œè€Œerrors.Aså‡½æ•°åˆ™ç”¨äºå°†é”™è¯¯è½¬æ¢ä¸ºæŒ‡å®šç±»å‹çš„å˜é‡ã€‚</font>**
  - ä¾‹å¦‚ï¼Œå‡è®¾æœ‰ä¸€ä¸ªé”™è¯¯é“¾ï¼Œå…¶ä¸­åŒ…å«å¤šä¸ªé”™è¯¯å¯¹è±¡ï¼Œå¯ä»¥ä½¿ç”¨errors.Iså‡½æ•°æ¥åˆ¤æ–­é”™è¯¯é“¾ä¸­æ˜¯å¦å­˜åœ¨æŸä¸ªç‰¹å®šç±»å‹çš„é”™è¯¯ï¼Œè€Œä½¿ç”¨errors.Aså‡½æ•°æ¥å°†é”™è¯¯é“¾ä¸­çš„æŸä¸ªé”™è¯¯è½¬æ¢ä¸ºæŒ‡å®šç±»å‹çš„å˜é‡ï¼Œä»¥ä¾¿è¿›ä¸€æ­¥å¤„ç†è¯¥é”™è¯¯ã€‚
- å¯¹åŒ…è£…è¿‡çš„errorä¾ç„¶ç”Ÿæ•ˆ, éƒ½æ˜¯é€’å½’å¾ªç¯ï¼Œæ‹†åŒ…è·å–ä¸‹ä¸€å±‚error
- Is æ˜¯åšçš„æŒ‡é’ˆåœ°å€åˆ¤æ–­ï¼Œå¦‚æœé”™è¯¯ Error() å†…å®¹ä¸€æ ·ï¼Œä½†æ˜¯æ ¹ error æ˜¯ä¸åŒå®ä¾‹ï¼Œé‚£ä¹ˆ Is åˆ¤æ–­ä¹Ÿæ˜¯ false

### æºç è§£æ
``` go
// err è‡ªå·±å®ç°äº† interface{ Is(error) bool } æ¥å£ï¼Œ
func Is(err, target error) bool {
	if target == nil {
		return err == target
	}

	isComparable := reflectlite.TypeOf(target).Comparable()
	//forå¾ªç¯ï¼ŒæŠŠerrä¸€å±‚å±‚å‰¥å¼€ï¼Œä¸€ä¸ªä¸ªæ¯”è¾ƒï¼Œæ‰¾åˆ°å°±è¿”å›true
	for {
		if isComparable && err == target {
			return true
		}
		// é€šè¿‡æ¥å£æ–­è¨€ï¼Œå¯ä»¥è°ƒç”¨ Is æ–¹æ³•åˆ¤æ–­ err æ˜¯å¦ä¸ target ç›¸ç­‰ã€‚
		// è¿™é‡Œæ„å‘³ç€ä½ å¯ä»¥è‡ªå®šä¹‰errorçš„Isæ–¹æ³•ï¼Œå®ç°è‡ªå·±çš„æ¯”è¾ƒä»£ç 
		if x, ok := err.(interface{ Is(error) bool }); ok && x.Is(target) {
			return true
		}
		// å¦åˆ™é€’å½’è°ƒç”¨ Unwrap æ–¹æ³•æ‹†åŒ…è£…ï¼Œè¿”å›ä¸‹ä¸€å±‚çš„ error å»åˆ¤æ–­æ˜¯å¦ä¸ target ç›¸ç­‰ã€‚
		if err = Unwrap(err); err == nil {
			return false
		}
	}
}

// é€’å½’è°ƒç”¨ï¼Œå¦åˆ™æ¥å£æ–­è¨€å¤±è´¥ï¼Œè¿”å› nil
func Unwrap(err error) error {
	u, ok := err.(interface {
		Unwrap() error
	})
	if !ok {
		return nil
	}
	return u.Unwrap()
}

var errorType = reflectlite.TypeOf((*error)(nil)).Elem()

// æå–æŒ‡å®šç±»å‹çš„é”™è¯¯ï¼Œåˆ¤æ–­åŒ…è£…çš„ error é“¾ä¸­ï¼ŒæŸä¸€ä¸ª error çš„ç±»å‹æ˜¯å¦ä¸ target ç›¸åŒï¼Œå¹¶æå–ç¬¬ä¸€ä¸ªç¬¦åˆç›®æ ‡ç±»å‹çš„é”™è¯¯çš„å€¼ï¼Œå°†å…¶èµ‹å€¼ç»™ target
func As(err error, target any) bool {
	// ä¸€äº›åˆ¤æ–­ï¼Œä¿è¯targetï¼Œè¿™é‡Œæ˜¯ä¸èƒ½ä¸ºnil
	if target == nil {
		panic("errors: target cannot be nil")
	}
	val := reflectlite.ValueOf(target)
	typ := val.Type()
	// è¿™é‡Œç¡®ä¿targetå¿…é¡»æ˜¯ä¸€ä¸ªénilæŒ‡é’ˆ
	if typ.Kind() != reflectlite.Ptr || val.IsNil() {
		panic("errors: target must be a non-nil pointer")
	}
	targetType := typ.Elem()

	// è¿™é‡Œç¡®ä¿targetæ˜¯ä¸€ä¸ªæ¥å£æˆ–è€…å®ç°äº†erroræ¥å£
	if targetType.Kind() != reflectlite.Interface && !targetType.Implements(errorType) {
		panic("errors: *target must be interface or implement error") // è¦æ±‚ *target æ˜¯ä¸€ä¸ªæ¥å£æˆ–è€…å®ç°äº† error æ¥å£
	}
	// ä¸Šé¢ä»£ç éƒ¨åˆ†æ˜¯ç”¨æ¥çº¦æŸ target å‚æ•°çš„ç±»å‹ï¼Œè¦æ±‚å…¶æ˜¯ä¸€ä¸ªéç©ºçš„æŒ‡é’ˆç±»å‹ã€‚
	for err != nil {
		// err æ˜¯å¦å¯ä»¥èµ‹å€¼ç»™ target æ‰€å±ç±»å‹ï¼Œå¦‚æœå¯ä»¥åˆ™èµ‹å€¼è¿”å› true
		// æœ¬è´¨ä¸Šï¼Œå°±æ˜¯ç±»å‹æ–­è¨€ï¼Œè¿™æ˜¯åå°„çš„å†™æ³•
		if reflectlite.TypeOf(err).AssignableTo(targetType) {
			val.Elem().Set(reflectlite.ValueOf(err))
			return true
		}
		// é€šè¿‡æ¥å£æ–­è¨€ï¼Œå¯ä»¥è°ƒç”¨ As æ–¹æ³•åˆ¤æ–­
		//è¿™é‡Œæ„å‘³ç€ä½ å¯ä»¥è‡ªå®šä¹‰errorçš„Asæ–¹æ³•ï¼Œå®ç°è‡ªå·±çš„ç±»å‹æ–­è¨€ä»£ç 
		if x, ok := err.(interface{ As(any) bool }); ok && x.As(target) {
			return true
		}
		// å¦åˆ™ä¹Ÿæ˜¯èµ°é€’å½’æ‹†åŒ…çš„é€»è¾‘ã€‚è¿™é‡Œæ˜¯éå†erroré“¾çš„å…³é”®ï¼Œä¸åœçš„Unwrapï¼Œä¸€å±‚å±‚çš„è·å–err
		err = Unwrap(err)
	}
	return false
}
```

- ä¾‹å­ errors.Is
``` go
// [errors.Is] çš„æ ¸å¿ƒé€»è¾‘ï¼š
// åŠŸèƒ½ï¼š åˆ¤æ–­ä¸€ä¸ªé”™è¯¯ err æ˜¯å¦ç­‰äºæŸä¸ªç‰¹å®šé”™è¯¯ targetï¼ˆæˆ–è¢«å…¶åŒ…è£¹ï¼‰ã€‚
// æ”¯æŒåµŒå¥—ï¼š ä¼šé€’å½’åœ°æ²¿ç€ Unwrap() æˆ– Unwrap() []error æ‹†å¼€ error æ ‘ï¼Œæ·±åº¦ä¼˜å…ˆéå†ã€‚
// åŒ¹é…æ–¹å¼ï¼š
//
//	å¦‚æœ err == targetï¼Œè¿”å› trueï¼›
//	å¦‚æœ err å®ç°äº† Is(error) bool æ–¹æ³•ï¼Œå¹¶è¿”å› trueï¼Œä¹Ÿç®—åŒ¹é…ã€‚
var ErrExample = errors.New("ç¤ºä¾‹é”™è¯¯")

type ExampleErrorForIs struct{}

func (ce ExampleErrorForIs) Error() string {
	return "custom error"
}

func (ce ExampleErrorForIs) Is(target error) bool {
	return target.Error() == "custom error" // è‡ªå·±å®ç° å¯¹æ¯”errorçš„å±æ€§å€¼
}
func TestErrorIs(t *testing.T) {
	errA := fmt.Errorf("åŒ…è£…ç¬¬ä¸€å±‚: %w", ErrExample)
	errB := fmt.Errorf("åŒ…è£…ç¬¬äºŒå±‚: %w", errA)

	// åŒ…è£…åçš„é”™è¯¯ä¸åŸå§‹é”™è¯¯ç›´æ¥æ¯”è¾ƒï¼šä¸ç›¸ç­‰
	// åŒ…è£…åçš„é”™è¯¯ï¼Œå¯é€šè¿‡errors.Isæ¥åˆ¤æ–­æ˜¯å¦æ˜¯å¦ä¸ªé”™è¯¯æˆ–ç”±æŸä¸ªé”™è¯¯åŒ…è£…è€Œæ¥ï¼ˆæ·±åº¦ä¼˜å…ˆéå†ï¼‰
	if errors.Is(errA, ErrExample) {
		t.Log("errA ä¸ ErrExample ç›¸ç­‰")
	} else {
		t.Log("errA ä¸ ErrExample ä¸ç›¸ç­‰")
	}
	if errors.Is(errB, errA) {
		t.Log("errB ä¸ errA ç›¸ç­‰")
	} else {
		t.Log("errB ä¸ errA ä¸ç›¸ç­‰")
	}
	if errors.Is(errB, ErrExample) {
		t.Log("errB ä¸ ErrExample ç›¸ç­‰")
	} else {
		t.Log("errB ä¸ ErrExample ä¸ç›¸ç­‰")
	}
}

// å®ç°äº† Is æ–¹æ³•çš„è‡ªå®šä¹‰é”™è¯¯
func TestErrorIs_æœ‰å®ç°Isæ–¹æ³•(t *testing.T) {
	errA := errors.New("custom error")
	ce := &ExampleErrorForIs{}

	assert.True(t, errors.Is(ce, errA))
}

func TestErrorIs_ç›¸åŒé”™è¯¯å†…å®¹çš„ä¸åŒå®ä¾‹(t *testing.T) {
	var errMsg = "é”™è¯¯ä¿¡æ¯"
	errA := errors.New(errMsg)
	errB := errors.New(errMsg)

	spew.Printf("é”™è¯¯A: %+#v \né”™è¯¯B: %+#v\n", errA, errB)

	// ç›´æ¥æ¯”è¾ƒï¼šä¸ç›¸ç­‰ï¼ˆå…¶å®å°±æ˜¯ç»“æ„ä½“æ¯”è¾ƒï¼‰
	if errA == errB {
		fmt.Println("ç›¸ç­‰")
	}
	// Isåˆ¤æ–­ ç›¸åŒé”™è¯¯å†…å®¹çš„ä¸åŒå®ä¾‹æ˜¯false
	if errors.Is(errA, errB) {
		fmt.Println("errA ä¸ errB ç›¸ç­‰")
	} else {
		fmt.Println("errA ä¸ errB ä¸ç›¸ç­‰")
	}
	// æ³¨æ„assertåŒ…çš„Equalæ˜¯ä¼šåˆ¤æ–­ä¸ºtrueçš„ï¼ˆå› ä¸ºä¼šä½¿ç”¨[reflect.DeepEqual]ï¼‰
	assert.Equal(t, errA, errB) // æ–­è¨€é‡Œä¼šåˆ¤æ–­ç›¸ç­‰çš„

}

```

- ä¾‹å­ errors.As
``` go
// åœ¨é”™è¯¯é“¾ä¸­æŸ¥æ‰¾ç¬¬ä¸€ä¸ªåŒ¹é…æŸä¸ªç±»å‹çš„é”™è¯¯ï¼Œå¦‚æœæ‰¾åˆ°åˆ™å°†å…¶èµ‹å€¼ç»™ç›®æ ‡å˜é‡ï¼Œå¹¶è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚
// ğŸ” åŒ¹é…æ¡ä»¶
// é”™è¯¯çš„å®é™…ç±»å‹å¯ä»¥èµ‹å€¼ç»™ target æŒ‡å‘çš„ç±»å‹ï¼ˆå³ç±»å‹å…¼å®¹ï¼‰ã€‚
// æˆ–è€…é”™è¯¯å®ç°äº† As(any) bool æ–¹æ³•ï¼Œå¹¶è¿”å› trueã€‚
//
// ğŸŒ² é”™è¯¯æ ‘ï¼ˆError Treeï¼‰
// åŒ…æ‹¬ err æœ¬èº«ï¼›
// ä»¥åŠé€šè¿‡ä¸æ–­è°ƒç”¨ Unwrap() æˆ– Unwrap() []error å¾—åˆ°çš„åµŒå¥—é”™è¯¯ï¼›
// å¤šä¸ªåµŒå¥—é”™è¯¯æ—¶ï¼Œé‡‡ç”¨**æ·±åº¦ä¼˜å…ˆéå†ï¼ˆdepth-first traversalï¼‰**æ–¹å¼æŸ¥æ‰¾ã€‚
//
// âš ï¸ æ³¨æ„äº‹é¡¹
// target å¿…é¡»æ˜¯ä¸€ä¸ªé nil çš„æŒ‡é’ˆï¼ŒæŒ‡å‘å®ç°äº† error æ¥å£çš„ç±»å‹æˆ–æ¥å£ç±»å‹ï¼Œå¦åˆ™ä¼š panicï¼›
// åªèƒ½æ‰¾åˆ°ç¬¬ä¸€ä¸ªåŒ¹é…çš„é”™è¯¯ã€‚

type TypicalErr struct {
	e string
}

func (t TypicalErr) Error() string {
	return t.e
}

func TestErrAs(t *testing.T) {
	err := TypicalErr{"typical error"}
	err1 := fmt.Errorf("wrap err: %w", err)
	err2 := fmt.Errorf("wrap err1: %w", err1)
	var e TypicalErr
	if !errors.As(err2, &e) {
		panic("TypicalErr is not on the chain of err2")
	}
	println("TypicalErr is on the chain of err2") // TypicalErr is on the chain of err2
	println(err == e) // true
}

```
è¿™ä¸¤ä¸ªå‡½æ•°çš„ä¸»è¦åŒºåˆ«åœ¨äºå®ƒä»¬çš„è¿”å›å€¼å’Œç”¨é€”ã€‚errors.Iså‡½æ•°è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ï¼Œç”¨äºåˆ¤æ–­é”™è¯¯æ˜¯å¦ä¸ç»™å®šç±»å‹åŒ¹é…ï¼Œè€Œerrors.Aså‡½æ•°è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ï¼ŒåŒæ—¶ä¼šå°†é”™è¯¯çš„å€¼èµ‹ç»™æŒ‡å®šç±»å‹çš„å˜é‡ã€‚

- å®¹æ˜“è¸©å‘çš„æ¡ˆä¾‹ æ¥å£å˜é‡å’ŒæŒ‡é’ˆå˜é‡å¯¹äºnilåŒºåˆ«
``` go
type CustomError struct {
}
func (c *CustomError) Error() string {
	return "è‡ªå®šä¹‰é”™è¯¯"
}
func main() {
	var e error = nil
	var c *CustomError = nil
	e = c
	spew.Dump(
		e,
		e == nil, // 1 false
		c,
		c == nil, // 2 true
	)
}

// e == nilï¼ˆ1ï¼‰ï¼š
//     e æ˜¯ä¸€ä¸ª error æ¥å£å˜é‡ï¼Œå®ƒçš„åŠ¨æ€ç±»å‹æ˜¯ *CustomErrorï¼ŒåŠ¨æ€å€¼æ˜¯ nilã€‚
//     ç”±äºåŠ¨æ€ç±»å‹ä¸ä¸º nilï¼Œå› æ­¤ e == nil çš„ç»“æœæ˜¯ falseã€‚
// c == nilï¼ˆ2ï¼‰ï¼š
//     c æ˜¯ä¸€ä¸ª *CustomError ç±»å‹çš„æŒ‡é’ˆå˜é‡ï¼Œå®ƒçš„å€¼æ˜¯ nilã€‚
//     å› æ­¤ï¼Œc == nil çš„ç»“æœæ˜¯ trueã€‚

```
- è¸©å‘ä¾‹å­
``` go
type CustomError2 struct {
	Code int
	Msg  string
}

func (c *CustomError2) Error() string {
	return fmt.Sprintf("è‡ªå®šä¹‰é”™è¯¯, code: %d, msg: %s", c.Code, c.Msg)
}
func Handle(content string) error {
	var e *CustomError2 // æ­£å¸¸çš„åº”è¯¥æ˜¯åƒ var e CustomError3
	if content != "" {
		// (*err_test.CustomError2)<nil> ä¸ç­‰äº nil
		return e // å®¹æ˜“è¸©å‘çš„ç‚¹ æ­¤æ—¶è¿”å›çš„errorç±»å‹ï¼ˆæ˜¯æ¥å£ï¼‰çš„å˜é‡ï¼ŒåŠ¨æ€ç±»å‹æ˜¯ *CustomError2ï¼ŒåŠ¨æ€å€¼æ˜¯ nilã€‚
		//  *errors.errorString *fmt.wrapError *err_test.CustomError2
	}
	e = &CustomError2{
		Code: 1,
		Msg:  "å†…å®¹ä¸ºç©º",
	}
	return e
}
func TestError(t *testing.T) {
	c1 := "xx"
	err := Handle(c1)
	// è¸©å‘ç‚¹ å®¹æ˜“ç›´æ¥åˆ¤æ–­ä¸ºnil æ­¤æ—¶ e æ˜¯ä¸€ä¸ª erroræ¥å£å˜é‡ï¼Œå®ƒçš„åŠ¨æ€ç±»å‹æ˜¯ *CustomError2ï¼ŒåŠ¨æ€å€¼æ˜¯ nilã€‚
	// ç”±äºåŠ¨æ€ç±»å‹ä¸ä¸º nilï¼Œå› æ­¤ e == nil çš„ç»“æœæ˜¯ falseã€‚
	if err != nil {
		spew.Printf("å¤„ç†c1å¤±è´¥, err=%+#v\n", err) // å¤„ç†c1å¤±è´¥, err=(*err_test.CustomError2)<nil>
	}
	c2 := ""
	err = Handle(c2)
	if err != nil {
		spew.Printf("å¤„ç†c2å¤±è´¥, err=%+#v\n", err) // å¤„ç†c2å¤±è´¥, err=(*err_test.CustomError2)(0x1400000e300)è‡ªå®šä¹‰é”™è¯¯, code: 1, msg: å†…å®¹ä¸ºç©º
	}
}

type CustomError3 struct {
	Code int
	Msg  string
}

func (c *CustomError3) Error() string {
	return fmt.Sprintf("è‡ªå®šä¹‰é”™è¯¯, code: %d, msg: %s", c.Code, c.Msg)
}
func Handle3(content string) error {
	var e CustomError3
	if content != "" {
		// è¿™é‡Œå› ä¸ºerroræ˜¯çš„æ–¹æ³•Error()æ˜¯å½’å±ç»“æ„ä½“æŒ‡é’ˆçš„ æ‰€ä»¥è¦&e
		return &e // è¿”å›çš„ æ˜¯å·²ç»åˆ†é…åœ°å€çš„ç»“æ„ä½“æŒ‡é’ˆ è‚¯å®šä¸ä¸ºnil
	}
	e = CustomError3{
		Code: 1,
		Msg:  "å†…å®¹ä¸ºç©º",
	}
	return &e
}
func TestError3(t *testing.T) {
	c1 := "xx"
	err := Handle3(c1)
	if err != nil {
		spew.Printf("å¤„ç†c1å¤±è´¥, err=%+#v\n", err) // å¤„ç†c1å¤±è´¥, err=(*err_test.CustomError3)(0x1400000e300)è‡ªå®šä¹‰é”™è¯¯, code: 0, msg:
	}
	c2 := ""
	err = Handle3(c2)
	if err != nil {
		spew.Printf("å¤„ç†c2å¤±è´¥, err=%+#v\n", err) // å¤„ç†c2å¤±è´¥, err=(*err_test.CustomError3)(0x1400000e318)è‡ªå®šä¹‰é”™è¯¯, code: 1, msg: å†…å®¹ä¸ºç©º
	}
}

```

# errors.Join å¤šä¸ªé”™è¯¯
- ç”¨äºå°†å¤šä¸ªé”™è¯¯ç»„åˆæˆä¸€ä¸ªå•ä¸€çš„é”™è¯¯å€¼ã€‚è¿™æ˜¯ Go é”™è¯¯å¤„ç†æœºåˆ¶åœ¨æ”¯æŒå¤šé”™è¯¯ï¼ˆmulti-errorï¼‰æ–¹é¢çš„é‡è¦æ‰©å±•ã€‚
- <font color="red">1.20å¼•å…¥ ä»£æ›¿fmt.Errorf</font>
  
- https://github.com/uber-go/multierr ç¤¾åŒºåº“(çŸ¥é“ä¸‹å°±è¡Œ)
``` go
type CustomError struct {
	Msg string
}

func (e *CustomError) Error() string {
	return e.Msg
}

func TestJoin(t *testing.T) {
	errA := errors.New("é”™è¯¯A")
	errB := errors.New("é”™è¯¯B")
	errC := &CustomError{Msg: "é”™è¯¯C"}

	errJoined := errors.Join(errA, errB, errC)

	spew.Printf("errJoined: %+#v\n", errJoined)
	assert.True(t, errors.Is(errJoined, errA))
	assert.True(t, errors.Is(errJoined, errB))
	assert.True(t, errors.Is(errJoined, errC))
	var ce *CustomError
	assert.True(t, errors.As(errJoined, &ce))
}
```

# wrapError ç¬¬ä¸‰æ–¹åº“ (åªåšäº†è§£)
- å½“å‰ error çš„é—®é¢˜æœ‰ä¸¤ç‚¹
   - <font color="red">å½“ go1.13 åï¼Œæ ‡å‡†åº“ errors å¢åŠ äº† Wrap, Is å’Œ As ç­‰åŠŸèƒ½,ä½†æ˜¯æ²¡æœ‰æä¾›å¢åŠ è°ƒç”¨æ ˆçš„æ–¹æ³•.</font>
   - æ— æ³• wrap æ›´å¤šçš„ä¿¡æ¯ï¼Œæ¯”å¦‚è°ƒç”¨æ ˆï¼Œæ¯”å¦‚å±‚å±‚å°è£…çš„ error æ¶ˆæ¯ 
   - æ— æ³•å¾ˆå¥½çš„å¤„ç†ç±»å‹ä¿¡æ¯ï¼Œæ¯”å¦‚æˆ‘æƒ³çŸ¥é“é”™è¯¯æ˜¯ io ç±»å‹çš„ï¼Œè¿˜æ˜¯ net ç±»å‹çš„
- https://github.com/pkg/errors ç¬¬ä¸‰æ–¹åº“ (é”™è¯¯è¦æœ‰è°ƒç”¨æ ˆä¿¡æ¯æ—¶ç”¨) 
   -  <font color="red">ç›®å‰æ­¤é¡¹ç›®å·²å½’æ¡£ï¼Œé™¤ééå¸¸æ—©æœŸçš„é¡¹ç›®ï¼Œä¸å†æ¨èä½¿ç”¨ã€‚</font>
   - Wrap å°è£…åº•å±‚ error, å¢åŠ æ›´å¤šæ¶ˆæ¯ï¼Œæä¾›è°ƒç”¨æ ˆä¿¡æ¯ï¼Œè¿™æ˜¯åŸç”Ÿ error ç¼ºå°‘çš„
   - WithMessage å°è£…åº•å±‚ error, å¢åŠ æ›´å¤šæ¶ˆæ¯ï¼Œä½†ä¸æä¾›è°ƒç”¨æ ˆä¿¡æ¯
   - Cause è¿”å›æœ€åº•å±‚çš„ error, å‰¥å»å±‚å±‚çš„ wrap
``` go
import (
   "database/sql"
   "fmt"

   "github.com/pkg/errors"
)

func foo() error {
   return errors.Wrap(sql.ErrNoRows, "foo failed")
}

func bar() error {
   return errors.WithMessage(foo(), "bar failed")
}

func main() {
   err := bar()
   if errors.Cause(err) == sql.ErrNoRows {
      fmt.Printf("data not found, %v\n", err)
      fmt.Printf("%+v\n", err)
      return
   }
   if err != nil {
      // unknown error
   }
}
// æ‰“å°è¾“å‡º
// data not found, bar failed: foo failed: sql: no rows in result set
// sql: no rows in result set
// foo failed
// main.foo
//     /usr/three/main.go:11
// main.bar
//     /usr/three/main.go:15
// main.main
//     /usr/three/main.go:19
// runtime.main
//     ...

```
## æºç åˆ†æ
``` go
type withStack struct {
	error
	*stack
}

// ç”Ÿæˆ warapper error
func Wrap(err error, message string) error {
	if err == nil {
		return nil
	}
	err = &withMessage{
		cause: err,
		msg:   message,
	}
	return &withStack{
		err,
		callers(),
	}
}

func (w *withStack) Cause() error { return w.error }

func Cause(err error) error {
	type causer interface {
		Cause() error
	}

	for err != nil {
		cause, ok := err.(causer)
		if !ok {
			break
		}
		err = cause.Cause()
	}
	return err
}
```

# deferè¯­å¥
Go è¯­è¨€ä¸­çš„ç±»æ²¡æœ‰æ„é€ å‡½æ•°å’Œææ„å‡½æ•°çš„æ¦‚å¿µï¼Œå¤„ç†é”™è¯¯å’Œå¼‚å¸¸æ—¶ä¹Ÿæ²¡æœ‰æä¾› try...catch...finally ä¹‹ç±»çš„è¯­æ³•ï¼Œé‚£å½“æˆ‘ä»¬æƒ³è¦åœ¨æŸä¸ªèµ„æºä½¿ç”¨å®Œæ¯•åå°†å…¶é‡Šæ”¾ï¼ˆç½‘ç»œè¿æ¥ã€æ–‡ä»¶å¥æŸ„ç­‰ï¼‰ï¼Œæˆ–è€…åœ¨ä»£ç è¿è¡Œè¿‡ç¨‹ä¸­æŠ›å‡ºé”™è¯¯æ—¶æ‰§è¡Œä¸€æ®µå…œåº•é€»è¾‘

- é€šè¿‡ defer å…³é”®å­—<font color="red">å£°æ˜å…œåº•æ‰§è¡Œæˆ–è€…é‡Šæ”¾èµ„æºçš„è¯­å¥</font>, ç›¸å½“äºphpçš„ææ„å’Œfinally
- ä¸€ä¸ªå‡½æ•°/æ–¹æ³•ä¸­å¯ä»¥å­˜åœ¨å¤šä¸ª defer è¯­å¥, defer è¯­å¥çš„<font color="red">è°ƒç”¨é¡ºåºå…¥æ ˆå‡ºæ ˆ</font>ï¼Œæ‰§è¡Œé¡ºåºæ˜¯ä»åå¾€å‰æ‰§è¡Œ
- deferæ‰§è¡Œçš„æ—¶æœº, ç¦æ­¢åœ¨å¾ªç¯ä¸­ä½¿ç”¨ deferã€‚å®åœ¨æƒ³ä½¿ç”¨ï¼šå°†å¾ªç¯é‡Œçš„é€»è¾‘ä½¿ç”¨åŒ¿åå‡½æ•°å°è£…ï¼Œè¿™æ ·å°±å¯ä»¥åœ¨æ¯æ¬¡åŒ¿åå‡½æ•°ç»“æŸåè°ƒç”¨ä¸€æ¬¡)

``` go
// ä¸è¦è¿™æ ·ä½¿ç”¨
func filterSomething(values []string) {
    for _, v := range values {
        fields, err := db.Query(v) // ç¤ºä¾‹ï¼Œå®é™…ä¸è¦è¿™ä¹ˆæŸ¥è¯¢ï¼Œé˜²æ­¢sqlæ³¨å…¥
        if err != nil {
            // xxx
        }
        defer fields.Close() // 1. é¢„æœŸæ˜¯æ¯æ¬¡å¾ªç¯éƒ½è°ƒç”¨ä¸€æ¬¡ï¼Œä½†å®é™…æ˜¯åœ¨å¾ªç¯ç»“æŸåæ‰ä¼šè¢«è°ƒç”¨ä¸€æ¬¡
        // ç»§ç»­ä½¿ç”¨fields
    }
}

// åº”å½“ä½¿ç”¨å¦‚ä¸‹çš„æ–¹å¼ï¼š
func filterSomething(values []string) {
    for _, v := range values {
        func() {
            fields, err := db.Query(v) // ç¤ºä¾‹ï¼Œå®é™…ä¸è¦è¿™ä¹ˆæŸ¥è¯¢ï¼Œé˜²æ­¢sqlæ³¨å…¥
            if err != nil {
            ...
            }
            defer fields.Close() // 2. å°† å¾ªç¯é‡Œçš„é€»è¾‘ä½¿ç”¨åŒ¿åå‡½æ•°å°è£…ï¼Œè¿™æ ·å°±å¯ä»¥åœ¨æ¯æ¬¡åŒ¿åå‡½æ•°ç»“æŸåè°ƒç”¨ä¸€æ¬¡ defer db.Close()
            // ç»§ç»­ä½¿ç”¨fields
        }()
    }
}
```
- è¿è¡Œæ—¶æŠ›å‡ºé”™è¯¯ä¼šä¸­æ–­åé¢ä»£ç çš„æ‰§è¡Œï¼Œä¹Ÿå°±**æ„ŸçŸ¥ä¸åˆ°åé¢çš„ defer è¯­å¥ã€‚**
- <font color="red">è°ƒç”¨æ—¶åŒ¿åå‡½æ•°æ—¶ï¼Œæœ‰é—­åŒ…ï¼Œå¼•ç”¨å¤–éƒ¨å˜é‡æ—¶ï¼Œä»¥å½“æ—¶å€¼ä¸ºå‡†</font>, deferåé¢çš„å‡½æ•°åœ¨å…¥æ ˆçš„æ—¶å€™ä¿å­˜çš„æ˜¯å…¥æ ˆé‚£ä¸€åˆ»çš„å€¼ï¼Œè€Œå½“æ—¶xçš„å€¼æ˜¯10,åæœŸå¯¹ä¼ å…¥å‚æ•°ä¿®æ”¹ï¼Œå¹¶ä¸ä¼šå½±å“æ ˆå†…å‡½æ•°çš„å€¼


``` go
// å»¶è¿Ÿæ‰§è¡Œå‡½æ•°defer é€šå¸¸ç”¨äºæ¸…ç†æŸäº›èµ„æºå’Œå¤„ç†æŸäº›å¼‚å¸¸
// returnä¹‹åçš„è¯­å¥å…ˆæ‰§â¾ï¼Œdeferåçš„è¯­å¥åæ‰§â¾
// åœ¨ä¸€ä¸ªå‡½æ•°ä¸­,å¦‚æœæœ‰å¤šä¸ª defer é‚£å®ƒçš„æ‰§è¡Œé¡ºåºæ˜¯ä»åå¾€å‰æ‰§è¡Œ å…¥æ ˆå‡ºæ ˆï¼ŒåæœŸå¯¹ä¼ å…¥å‚æ•°ä¿®æ”¹ï¼Œå¹¶ä¸ä¼šå½±å“æ ˆå†…å‡½æ•°çš„å€¼
var tmpStr string = "hello world"

// panic ç¨‹åºå¼‚å¸¸ä¸­æ–­,åœ¨goé‡Œé¢ä»£è¡¨äº†ä¸å¯ä¿®å¤çš„é”™è¯¯,åœ¨goä¸­deferåœ¨panicä¹‹åä¹Ÿæ˜¯ä¼šæ‰§è¡Œçš„, ä½†æ˜¯æ³¨å†Œåœ¨panicä»£ç å‰é¢çš„è´¢æ‰§è¡Œï¼Œä¸”å€¼ä¸ºå½“æ—¶çš„ä¼ å…¥å€¼
func TestDefer(t *testing.T) {
	defer func() {
		fmt.Println("clear resources.", tmpStr)
	}()

	x := 10
	defer func(x int) {
		x++
		jbStr := "city"
		tmpStr = tmpStr + " ä¿®æ”¹å…¨å±€å˜é‡tmpStr" //
		fmt.Println(tmpStr, jbStr)

		fmt.Println("defer ", x) // 11
	}(x) //è¿™é‡Œè°ƒç”¨äº†xå˜é‡ deferåé¢çš„å‡½æ•°åœ¨å…¥æ ˆçš„æ—¶å€™ä¿å­˜çš„æ˜¯å…¥æ ˆé‚£ä¸€åˆ»çš„å€¼ï¼Œè€Œå½“æ—¶xçš„å€¼æ˜¯10ï¼Œæ‰€ä»¥åæœŸå¯¹xä¿®æ”¹ï¼Œå¹¶ä¸ä¼šå½±å“æ ˆå†…å‡½æ•°çš„å€¼

	x += 5
	fmt.Println("cur", x) // cur 15
	// x = x/0
	//panic("err") // panicåé¢çš„ä»£ç ä¸ä¼šè·‘ï¼ŒåŒ…æ‹¬åé¢æ‰æ³¨å†Œçš„defer
	// returnAndDeferFunc()

	fmt.Println(tmpStr) // hello world æ­£å¸¸æ‰§è¡Œä¸‹æ¥çš„

}
```
- returnä¹‹åçš„è¯­å¥å…ˆæ‰§â¾(è¿”å›å€¼å·²ç»èµ‹å€¼äº†,å¦‚æœè¿”å›çš„æ˜¯å¼•ç”¨å°±ä¼šå—åˆ°å½±å“)ï¼Œdeferåçš„è¯­å¥åæ‰§â¾
``` go
var testInt int

func TestOrder(t *testing.T) {
	testInt := returnAndDeferFunc()
	fmt.Println(testInt) // è¾“å‡º2
}

func deferFunc() {
	fmt.Println("defer func called...")
	testInt = 1
	fmt.Printf("defer func called...testInt:%d\n", testInt)
}

func returnFunc() int {
	fmt.Println("return func called...")
	testInt = 2
	fmt.Printf("return func called...testInt:%d\n", testInt)
	return testInt
}

// returnä¹‹åçš„è¯­å¥å…ˆæ‰§â¾ï¼ˆè¿”å›å€¼å˜é‡å·²ç»èµ‹å€¼ï¼Œåç»­deferé‡Œå†æ›´æ”¹ä¸ä¼šå½±å“ï¼Œé™¤éè¿”å›å€¼å˜é‡æ˜¯æŒ‡é’ˆï¼‰ï¼Œdeferåçš„è¯­å¥åæ‰§â¾
func returnAndDeferFunc() int {
	defer deferFunc()

	return returnFunc()
}

// return func called...
// return func called...testInt:2    returnå…ˆæ¥æ”¶è¿”å›å€¼2 ä¿å­˜ä¸‹æ¥äº†
// defer func called...
// defer func called...testInt:1
// 2 returnåç»­çš„defer å½±å“ä¸åˆ°å·²ä¿å­˜çš„è¿”å›å€¼
```
## ä½¿ç”¨å°æŠ€å·§
- æ‰“å°æ‰§è¡Œè€—æ—¶
![alt text](image3.png)
- å®ç°åœ¨å¦ä¸€ä¸ªå‡½æ•°çš„å¼€å¤´å’Œç»“å°¾å¤„æ‰§è¡Œä¸€ä¸ªå‡½æ•°
![alt text](image4.png)

# panicåœºæ™¯
å½“ä»£ç è¿è¡Œæ—¶å‡ºé”™ï¼Œè€Œåˆæ²¡æœ‰åœ¨ç¼–ç æ—¶æ˜¾å¼è¿”å›é”™è¯¯æ—¶ï¼ŒGo è¯­è¨€ä¼šæŠ›å‡º panicï¼Œä¸­æ–‡è¯‘ä½œã€Œè¿è¡Œæ—¶ææ…Œã€ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å°†å…¶çœ‹ä½œ Go è¯­è¨€ç‰ˆçš„å¼‚å¸¸
1. å¯¹äºæŸäº›è¿è¡Œæ—¶é”™è¯¯ï¼Œæ¯”å¦‚æ•°ç»„è¶Šç•Œã€é™¤æ•°ä¸º0ã€ç©ºæŒ‡é’ˆå¼•ç”¨
2. åœ¨ä»£ç ä¸­æ˜¾å¼æŠ›å‡º panic, <font color="red">panic å‡½æ•°æ”¯æŒçš„å‚æ•°ç±»å‹æ˜¯ interface{} , func panic(v interface{})</font>
3. ä¸å¯æ¢å¤çš„é”™è¯¯ï¼šå¦‚é€»è¾‘æ–­è¨€å¤±è´¥ã€ç¨‹åºçŠ¶æ€å¼‚å¸¸ç­‰ã€‚
4. æ ‡å‡†åº“ä¸­çš„panicï¼šä¾‹å¦‚regexp.MustCompileåœ¨æ­£åˆ™è¡¨è¾¾å¼æ— æ•ˆæ—¶ä¼šè§¦å‘panicã€‚
  
## panicä¿¡æ¯
å½“é‡åˆ° panic æ—¶ï¼ŒGo è¯­è¨€ä¼š<font color="red">ä¸­æ–­å½“å‰åç¨‹åç»­ä»£ç çš„æ‰§è¡Œ</font>ï¼Œç„¶åæ‰§è¡Œåœ¨<font color="red">ä¸­æ–­ä»£ç ä¹‹å‰å®šä¹‰çš„ defer è¯­å¥</font>ï¼ˆæŒ‰ç…§å…ˆå…¥åå‡ºçš„é¡ºåºï¼‰ï¼Œæœ€å**ç¨‹åºé€€å‡ºå¹¶è¾“å‡º panic é”™è¯¯ä¿¡æ¯**ï¼Œä»¥åŠå‡ºç°é”™è¯¯çš„å †æ ˆè·Ÿè¸ªä¿¡æ¯
  - ç¬¬ä¸€è¡Œè¡¨ç¤ºå‡ºé—®é¢˜çš„åç¨‹ï¼Œ
  - ç¬¬äºŒè¡Œæ˜¯é—®é¢˜ä»£ç æ‰€åœ¨çš„åŒ…å’Œå‡½æ•°ï¼Œ
  - <font color="red">ç¬¬ä¸‰è¡Œæ˜¯é—®é¢˜ä»£ç çš„å…·ä½“ä½ç½®</font>
  - æœ€åä¸€è¡Œåˆ™æ˜¯ç¨‹åºçš„é€€å‡ºçŠ¶æ€
``` go
package main

import "fmt"

func main() {
    defer func() {
        fmt.Println("ä»£ç æ¸…ç†é€»è¾‘")
    }()

    var i = 1
    var j = 0
    if j == 0 {
        panic("é™¤æ•°ä¸èƒ½ä¸º0ï¼")
    }
    k := i / j
    fmt.Printf("%d / %d = %d\n", i, j, k)
}
```
![](panic1.png)

- ä¾‹å­1
``` go
goroutine 554286 [running]: // ç¬¬ä¸€è¡Œ
runtime.throw({0x133cbd3?, 0x12171a0?})
    /usr/local/go/src/runtime/panic.go:992 +0x71 fp=0xc0007f87e0 sp=0xc0007f87b0 pc=0x4382f1
runtime.mapassign_faststr(0x1141520, 0xc000bac0f0, {0x1351d36, 0x1}) // ç¬¬äºŒè¡Œ
    /usr/local/go/src/runtime/map_faststr.go:295 +0x38b fp=0xc0007f8848 sp=0xc0007f87e0 pc=0x41342b
smart-admp/internal/biz.(*DailyCostUseCase).checkTask(0xc000a13630, {0x156d478, 0xc000c6a8a0}, 0xc000efa4f0, 0xc00066ab60, 0x5?, 0xc000c6a930?, 0xc000c6b350?, 0xc000bac000?, 0xc000bac030, ...) // // ç¬¬ä¸‰è¡Œ é—®é¢˜ä»£ç çš„å…·ä½“ä½ç½®ï¼Œå¦‚æœåœ¨è°ƒç”¨æ ˆä¸Šæ²¡æœ‰æ‰¾åˆ°ä»»ä½• recover() è¯­å¥,panic ä¼šç»§ç»­å‘å¤–ä¼ æ’­,ç›´åˆ°åˆ°è¾¾è¯¥ Goroutine çš„å…¥å£ç‚¹ã€‚
    /builds/tuiguang/smart-admp/internal/biz/daily_cost.go:336 +0xe46 fp=0xc0007f8f70 sp=0xc0007f8848 pc=0xf83ce6
smart-admp/internal/biz.(*DailyCostUseCase).BatchCheck.func2()
    /builds/tuiguang/smart-admp/internal/biz/daily_cost.go:159 +0x65 fp=0xc0007f8fe0 sp=0xc0007f8f70 pc=0xf82805
runtime.goexit() // ç¬¬å››è¡Œç¨‹åºçš„é€€å‡ºçŠ¶æ€
    /usr/local/go/src/runtime/asm_amd64.s:1571 +0x1 fp=0xc0007f8fe8 sp=0xc0007f8fe0 pc=0x4684e1
created by smart-admp/internal/biz.(*DailyCostUseCase).BatchCheck
    /builds/tuiguang/smart-admp/internal/biz/daily_cost.go:159 +0xd7f
    
```
- ä¾‹å­äºŒ
![alt text](image1.jpg)

## panicçš„ä¼ æ’­:
  - å½“ä¸€ä¸ª Goroutine æ‰§è¡Œ panic æ—¶,panic ä¼šå‘ä¸Šå†’æ³¡,ä¼ é€’åˆ°è¯¥ Goroutine çš„è°ƒç”¨æ ˆé¡¶ã€‚
  - å¦‚æœåœ¨è°ƒç”¨æ ˆä¸Šæ²¡æœ‰æ‰¾åˆ°ä»»ä½• recover() è¯­å¥,panic ä¼šç»§ç»­å‘å¤–ä¼ æ’­,ç›´åˆ°åˆ°è¾¾è¯¥ Goroutine çš„å…¥å£ç‚¹ã€‚
  - <font color="red">å¦‚æœè¯¥ Goroutine æ˜¯ä¸» Goroutineæˆ–è€…ä¼ æ’­åˆ°ä¸»goroutine,panic ä¼šå¯¼è‡´æ•´ä¸ªç¨‹åºå´©æºƒã€‚</font>
  - å¦‚æœè¯¥ Goroutine æ˜¯ä¸€ä¸ªéä¸» Goroutine,panic ä¼šå¯¼è‡´è¯¥ Goroutine ç»ˆæ­¢,ä½†ä¸ä¼šå½±å“å…¶ä»– Goroutineã€‚

# recover() å‡½æ•°
é€šè¿‡ recover() å‡½æ•°å¯¹ panic è¿›è¡Œæ•è·å’Œå¤„ç†ï¼Œ<font color="red">ä»è€Œé¿å…ç¨‹åºå´©æºƒç„¶åç›´æ¥é€€å‡ºï¼Œè€Œæ˜¯ç»§ç»­å¯ä»¥æ‰§è¡Œåç»­ä»£ç ï¼Œå®ç°ç±»ä¼¼PHP ä¸­ try...catch è¯­å¥çš„åŠŸèƒ½ã€‚</font>
- è¿™ä¸ª panic çš„æ•è·åº”è¯¥<font color="red">æ”¾åˆ° defer è¯­å¥ä¸­</font>å®Œæˆï¼Œæ‰å¯ä»¥åœ¨æŠ›å‡º panic æ—¶é€šè¿‡ recover å‡½æ•°å°†å…¶æ•è·ï¼Œ**defer è¯­å¥æ‰§è¡Œå®Œæ¯•åï¼Œä¼šé€€å‡ºæŠ›å‡º panic çš„å½“å‰å‡½æ•°**
``` go
defer func() {
    if err := recover(); err != nil {
        fmt.Printf("Runtime panic caught: %v, stacktrace#%s\n", err, string(debug.Stack())
    }
}()
```
- é€šè¿‡ recover() å‡½æ•°<font color="red">æ•è·äº† panicï¼Œå¹¶æ‰“å°æ•è·åˆ°çš„é”™è¯¯ä¿¡æ¯ï¼Œè¿™ä¸ªæ—¶å€™ï¼Œ**ç¨‹åºä¼šé€€å‡ºå‡½æ•°è€Œä¸æ˜¯æ•´ä¸ªåº”ç”¨**</font>
- è°ƒç”¨ defer è¯­å¥å£°æ˜çš„åŒ¿åå‡½æ•°ï¼Œå¦‚æœæ²¡æœ‰panicå‘ç”Ÿï¼Œé‚£ä¹ˆrecover() å‡½æ•°è¿”å›å€¼ä¸º nilï¼Œä¸ä¼šæ‰§è¡Œ if åˆ†æ”¯ä»£ç 
**ç±»æ¯”ä¸º panicã€recoverã€defer ç»„åˆèµ·æ¥å®ç°äº†ä¼ ç»Ÿé¢å‘å¯¹è±¡ç¼–ç¨‹å¼‚å¸¸å¤„ç†çš„ tryâ€¦catchâ€¦finally åŠŸèƒ½ã€‚**

## ä½¿ç”¨åœºæ™¯
- *<font color="red">åªæœ‰åœ¨å¸Œæœ›åœ¨æŸä¸ª Goroutine å‡ºç° panic æ—¶,èƒ½å¤Ÿä¼˜é›…åœ°æ¢å¤æˆ–å¤„ç†å®ƒ,è€Œä¸æ˜¯è®©æ•´ä¸ªç¨‹åºå´©æºƒæ—¶,æ‰éœ€è¦ä½¿ç”¨ recover()ã€‚</font>
- å¸¸è§çš„ä½¿ç”¨åœºæ™¯åŒ…æ‹¬:
  - åœ¨ HTTP æœåŠ¡å™¨çš„å¤„ç†ç¨‹åºä¸­ä½¿ç”¨ recover(),ä»¥é˜²æ­¢å•ä¸ªè¯·æ±‚å¯¼è‡´æ•´ä¸ªæœåŠ¡å™¨å´©æºƒã€‚
  - åœ¨é•¿æœŸè¿è¡Œçš„ Goroutine ä¸­ä½¿ç”¨ recover(),ä»¥ç¡®ä¿å®ƒä»¬ä¸ä¼šå› ä¸º panic è€Œé€€å‡ºã€‚
  - åœ¨æŸäº›å…³é”®çš„ä¸šåŠ¡é€»è¾‘ä¸­ä½¿ç”¨ recover(),ä»¥é˜²æ­¢å±€éƒ¨é”™è¯¯å¯¼è‡´æ•´ä¸ªç³»ç»Ÿå¤±è´¥ã€‚
``` go
func myHandler(w http.ResponseWriter, r *http.Request) {
    defer func() {
        if r := recover(); r != nil {
            log.Printf("Recovered from panic: %v\n%s", r, debug.Stack())
            http.Error(w, "Internal Server Error", http.StatusInternalServerError)
        }
    }()

    // å¤„ç†è¯·æ±‚çš„é€»è¾‘
}
```

## å¼€æ–°åç¨‹å°±è¦æ•æ‰
![](image2.png)
- åœ¨åç¨‹é‡Œï¼Œæ²¡æœ‰ recover çš„è¯ï¼Œç©ºæŒ‡é’ˆå¼‚å¸¸å°±ç›´æ¥å¯¼è‡´ ç¨‹åºé€€å‡ºäº†ï¼ˆä¹Ÿæ˜¯ panic çš„ä¸€ç§ï¼Œåªæ˜¯ä¸ºäº†å’Œä¸Šé¢ç›´æ¥ panic åšåŒºåˆ«ï¼‰
  - åç¨‹é‡Œçš„ recover åªèƒ½å¤„ç†æœ¬åç¨‹çš„ panicï¼Œåç¨‹é‡Œå†å¼€åç¨‹ï¼Œå­åç¨‹å®é™…ä¸Šä¹Ÿæ˜¯ä»å±äº main åç¨‹çš„
  - **<font color="red">åç¨‹å¿…é¡»è‡ªå·± recover panicï¼Œä¸ç„¶æ²¡æœ‰ recover çš„ panic ä¼š pop åˆ° main åç¨‹ï¼ˆmain åç¨‹æ˜¯ go ç›´æ¥ç®¡æ§çš„ï¼Œå®ƒä¸ä¼šè¿›è¡Œ recover å¤„ç†ï¼ˆç¨‹åºå°±ä¼šé€€å‡ºï¼‰ï¼Œå¯¼è‡´ç¨‹åºé€€å‡º</font>**

# Fatalç­‰ä»·os.Exit(1) æ¥é€€å‡ºç¨‹åº
- fatal æ˜¯ log åŒ…ä¸­çš„ä¸€ä¸ªå‡½æ•°,å®ƒä¼šæ‰“å°å‡ºé”™è¯¯ä¿¡æ¯å¹¶ç«‹å³ç»ˆæ­¢ç¨‹åºçš„æ‰§è¡Œã€‚
- fatal å‡½æ•°å†…éƒ¨å®é™…ä¸Šæ˜¯è°ƒç”¨äº† os.Exit(1) æ¥é€€å‡ºç¨‹åºã€‚
- ä½¿ç”¨ fatal å‡½æ•°,ç¨‹åºä¼šä»¥éé›¶çš„é€€å‡ºç é€€å‡º,è¡¨ç¤ºç¨‹åºè¿è¡Œå¤±è´¥
``` go
func main() {
        host := flag.String("host", "127.0.0.1", "ç›‘å¬åœ°å€")
        port := flag.Int("port", 8080, "ç›‘å¬ç«¯å£")
        appName := flag.String("name", "", "æœåŠ¡å")
        flag.Parse()

        if *appName == "" {
                log.Fatalln("æœåŠ¡åæœªå®šä¹‰") // å†…éƒ¨è°ƒç”¨os.Exit(1) æ¥é€€å‡ºç¨‹åºã€‚
        }

        fmt.Println(*host, *port, *appName)
}
```
## ä½¿ç”¨åœºæ™¯
- fatal: å½“é‡åˆ°æ— æ³•ç»§ç»­æ‰§è¡Œçš„ä¸¥é‡é”™è¯¯æ—¶ä½¿ç”¨,æ¯”å¦‚æ— æ³•è¿æ¥æ•°æ®åº“ã€æ— æ³•æ‰“å¼€æ–‡ä»¶ç­‰ã€‚è¿™ç§æƒ…å†µä¸‹,ç¨‹åºæ— æ³•ç»§ç»­è¿è¡Œ,éœ€è¦ç«‹å³ç»ˆæ­¢å¹¶åé¦ˆç»™è°ƒç”¨æ–¹ã€‚
- panic: å½“é‡åˆ°æ— æ³•é¢„æ–™çš„ã€ç¨‹åºæ— æ³•ç»§ç»­è¿è¡Œçš„é”™è¯¯æ—¶ä½¿ç”¨,æ¯”å¦‚æ•°ç»„è¶Šç•Œã€é™¤ä»¥é›¶ç­‰ã€‚è¿™ç§æƒ…å†µä¸‹,å¯ä»¥ä½¿ç”¨ panic ä¸­æ–­ç¨‹åºçš„æ‰§è¡Œ,å¹¶ç”±ä¸Šå±‚çš„ recover æ¥å¤„ç†


# å¤šåç¨‹çš„é”™è¯¯å¤„ç†ï¼Œæ ‡å‡†åº“errgroup
- <font color="red">å¹¶å‘åœºæ™¯ä¸‹ï¼Œå¦‚æœä¸€ä¸ª goroutine æœ‰é”™è¯¯ï¼Œé‚£ä¹ˆå°±è¦æå‰è¿”å›ï¼Œå¹¶å–æ¶ˆå…¶å®ƒå¹¶è¡Œçš„è¯·æ±‚</font>
- åº•å±‚ä½¿ç”¨ context æ¥ cancel å…¶å®ƒè¯·æ±‚ï¼ŒåŒæ­¥ä½¿ç”¨ WaitGroup, åŸç†éå¸¸ç®€å•

errgroupåŒ…æä¾›äº†ä¸€ç§æ–¹ä¾¿çš„æ–¹å¼æ¥è·Ÿè¸ªå’Œå¤„ç†å¤šä¸ªgoroutineä¸­çš„é”™è¯¯ã€‚å®ƒå¯ä»¥è®©ä½ å¯åŠ¨å¤šä¸ªgoroutineï¼Œå¹¶ç­‰å¾…å®ƒä»¬å…¨éƒ¨å®Œæˆï¼Œæˆ–è€…åœ¨ä»»ä½•ä¸€ä¸ªgoroutineè¿”å›é”™è¯¯æ—¶ç«‹å³å–æ¶ˆæ‰€æœ‰å…¶ä»–goroutineã€‚
{{< innerlink src="posts/tech/go48.md" >}}

## ä½¿ç”¨æ³¨æ„
1. context æ˜¯è°ä¼ è¿›æ¥çš„ï¼Ÿå…¶å®ƒä»£ç ä¼šä¸ä¼šç”¨åˆ°ï¼Œcancel åªèƒ½æ‰§è¡Œä¸€æ¬¡ï¼Œçæ¯”ç”¨ä¼šå‡ºé—®é¢˜
2. g.Go ä¸å¸¦ recover çš„ï¼Œä¸ºäº†ç¨‹åºçš„å¥å£®ï¼Œä¸€å®šè¦è‡ªè¡Œ recover
3. å¹¶è¡Œçš„ goroutine æœ‰ä¸€ä¸ªé”™è¯¯å°±è¿”å›ï¼Œè€Œä¸æ˜¯æ™®é€šçš„ fan-out è¯·æ±‚åæ”¶é›†ç»“æœ

# å®é™…å¤„ç†
1. error ä¸ panic
ç†è®ºä¸Š panic åªå­˜åœ¨äº server å¯åŠ¨é˜¶æ®µï¼Œæ¯”å¦‚ config æ–‡ä»¶è§£æå¤±è´¥ï¼Œç«¯å£ç›‘å¬å¤±è´¥ç­‰ç­‰ï¼Œæ‰€æœ‰ä¸šåŠ¡é€»è¾‘ç¦æ­¢ä¸»åŠ¨ panic
æ‰€æœ‰å¼‚æ­¥çš„ goroutine éƒ½è¦ç”¨ recover å»å…œåº•å¤„ç†
2. é”™è¯¯å¤„ç†ä¸èµ„æºé‡Šæ”¾
``` go
// ä¸€èˆ¬å¼‚æ­¥ç»„è£…æ•°æ®ï¼Œéƒ½è¦åˆ†åˆ«å¯åŠ¨ goroutine, ç„¶åæŠŠç»“æœé€šè¿‡ channel è¿”å›ï¼Œresult ç»“æ„ä½“æ‹¥æœ‰ err å­—æ®µè¡¨ç¤ºé”™è¯¯
func worker(done chan error) {
    err := doSomething()
    result := &result{}
    if err != nil {
        result.Err = err
    }
    done <- result
}
```
è¦æ³¨æ„ï¼Œmain å‡½æ•°ä¸­ done channel åƒä¸‡ä¸èƒ½ close, å› ä¸ºä½ ä¸çŸ¥é“ doSomething ä¼šè¶…æ—¶å¤šä¹…è¿”å›ï¼Œå†™ closed channel ç›´æ¥ panic
- **<font color="red">å‡†åˆ™ï¼šæ•°æ®ä¼ è¾“å’Œé€€å‡ºæ§åˆ¶ï¼Œéœ€è¦ç”¨å•ç‹¬çš„ channel ä¸èƒ½æ··, æˆ‘ä»¬ä¸€èˆ¬ç”¨ context å–æ¶ˆå¼‚æ­¥ goroutine, è€Œä¸æ˜¯ç›´æ¥ close channels</font>**

3. error çº§è”ä½¿ç”¨é—®é¢˜(é‡å¤ä½¿ç”¨)
``` go
type myError struct {
	string
}

func (i *myError) Error() string {
	return i.string
}

func Call1() error {
	return nil
}

func Call2() *myError {
	return nil
}

func main() {
	err := Call1()
	if err != nil {
		fmt.Printf("call1 is not nil: %v\n", err)
	}

	err = Call2() // å¤ç”¨ err å˜é‡çš„æƒ…å†µä¸‹ï¼Œ Call2 è¿”å›çš„ error æ˜¯è‡ªå®šä¹‰ç±»å‹
    // å¯¼è‡´ç»å…¸çš„ error is not nil, but value is nil
	if err != nil {
		fmt.Printf("call2 err is not nil: %v\n", err)
	}
}
```
-  è§£å†³æ–¹æ³•å°±æ˜¯ Call2 err é‡æ–°å®šä¹‰ä¸€ä¸ªå˜é‡ err2 = Call2()

4. ä¸è¦å¹¶å‘å¯¹ error èµ‹å€¼
go å†…ç½®ç±»å‹é™¤äº† channel å¤§éƒ¨åˆ†éƒ½æ˜¯éçº¿ç¨‹å®‰å…¨çš„ï¼Œerror ä¹Ÿä¸ä¾‹å¤–
``` go
package main
import (
   "fmt"
   "github.com/myteksi/hystrix-go/hystrix"
   "time"
)
var FIRST error = hystrix.CircuitError{Message:"timeout"}
var SECOND error = nil
func main() {
   var err error
   // å¹¶å‘å¯¹ error èµ‹å€¼ erroréçº¿ç¨‹å®‰å…¨
   go func() {
      i := 1
      for {
         i = 1 - i
         if i == 0 {
            err = FIRST
         } else {
            err = SECOND
         }
         time.Sleep(10)
      }
   }()
   for {
      if err != nil {
        // è¿›æ¥å erråˆè¢«å¹¶å‘èµ‹å€¼æˆniläº†
         fmt.Println(err.Error())
      }
      time.Sleep(10)
   }
}
//  ä¸€å¼€å§‹å®‰å…¨ ä½†æ˜¯æ‰§è¡Œä¸€ä¼šè¿˜æ˜¯ä¼šæŠ¥panic ç©ºæŒ‡é’ˆ

// hystrix: timeout
// panic: value method github.com/myteksi/hystrix-go/hystrix.CircuitError.Error called using nil *CircuitError pointer

// goroutine 1 [running]:
// github.com/myteksi/hystrix-go/hystrix.(*CircuitError).Error(0x0, 0xc0000f4008, 0xc000088f40)
//  <autogenerated>:1 +0x86
// main.main()
//  /Users/zerun.dong/code/gotest/panic.go:25 +0x82
// exit status 2
```
- åªè¦è·‘ä¸€ä¼šï¼Œå°±ä¸€å®šå‘ç”Ÿ panic, æœ¬è´¨å°±æ˜¯ error æ¥å£ç±»å‹ä¸æ˜¯å¹¶å‘å®‰å…¨çš„
``` go
// æ²¡æœ‰æ–¹æ³•çš„interface
type eface struct {
    _type *_type
    data  unsafe.Pointer
}
// æœ‰æ–¹æ³•çš„interface
type iface struct {
    tab  *itab
    data unsafe.Pointer
}
```
5. æ‰“å°è°ƒç”¨æ ˆ
å®˜æ–¹åº“æ— æ³• wrap è°ƒç”¨æ ˆï¼Œæ‰€ä»¥ fmt.Errorf %w ä¸å¦‚ pkg/errors åº“å®ç”¨ï¼Œä½†æ˜¯ errors.Wrap æœ€å¥½ä¿è¯åªè°ƒç”¨ä¸€æ¬¡ï¼Œå¦åˆ™å…¨æ˜¯é‡å¤è°ƒç”¨æ ˆ

6. pipeline å¤„ç†
``` go
_, err = fd.Write(p0[a:b])
if err != nil {
    return err
}
_, err = fd.Write(p1[c:d])
if err != nil {
    return err
}
_, err = fd.Write(p2[e:f])
if err != nil {
    return err
}
// and so on
// ä¸Šé¢æ˜¯åŸå§‹ä¾‹å­ï¼Œéœ€è¦ä¸€ç›´åš if err != nil çš„åˆ¤æ–­

// ä¼˜åŒ–å
type errWriter struct {
    w   io.Writer
    err error
}

func (ew *errWriter) write(buf []byte) {
    if ew.err != nil {
        return
    }
    _, ew.err = ew.w.Write(buf)
}

// ä½¿ç”¨æ—¶
ew := &errWriter{w: fd}
ew.write(p0[a:b])
ew.write(p1[c:d])
ew.write(p2[e:f])
// and so on
if ew.err != nil {
    return ew.err
}
```

# æ—¥å¿—çš„å¤„ç†ç»éªŒ
todo: bç«™è§†é¢‘æ€»ç»“ä¸‹

ä¸€ä¸ªé”™è¯¯åº”è¯¥åªè¢«å¤„ç†ä¸€æ¬¡ã€‚è®°å½•æ—¥å¿—æœ¬èº«å°±æ˜¯ä¸€ç§å¤„ç†è¡Œä¸ºã€‚æ‰€ä»¥ï¼Œä¸€ä¸ªé”™è¯¯è¦ä¹ˆè¢«è®°å½•ï¼ˆlogï¼‰ï¼Œè¦ä¹ˆè¢«å‘ä¸Šä¼ é€’ï¼ˆpropagateï¼‰ï¼Œä¸è¦åŒæ—¶åšä¸¤è€…ã€‚