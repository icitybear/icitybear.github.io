---
title: "Go-errgroup包多协程的错误处理" #标题
date: 2024-04-16T11:48:39+08:00 #创建时间
lastmod: 2024-04-16T11:48:39+08:00 #更新时间
author: ["citybear"] #作者
categories: # 没有分类界面可以不填写
- tech
tags: # 标签
- go包
- go并发编程
- go源码
keywords: 
- 
description: "" #描述 每个文章内容前面的展示描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true #是否展示评论 有自带的扩展成twikoo
showToc: true # 显示目录 文章侧边栏toc目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
    image: "" #图片路径：posts/tech/文章1/picture.png
    caption: "" #图片底部描述
    alt: ""
    relative: false

# reward: true # 打赏
mermaid: true #自己加的是否开启mermaid
---

# 注意点

- <font color="red">golang.org/x/sync/errgroup 是官方为我们提供的扩展库，在 sync.WaitGroup 基础上，增加了处理任务返回错误的能力。提供了同步、错误传播和上下文取消功能，用于一组goroutines处理共同任务的子任务</font

1. errgroup.WithContext 超时控制，errgroup.New 未携带context
2. 本身使用eg.Go方法就已经进入 内置的工作组了, 子协程注意捕捉panic (在Go()方法中，通过recover()函数捕获可能发生的panic，并将其转换为错误类型返回。因为是新起的一个协程)
3. for循环里使用go起新协程，<font color="red">协程里使用外部变量，会有竞争问题</font>，所以要赋值给一个新变量, 
   - 要使用map，那么要使用 sync.Map去存放，要改变结构体成员属性，那么还是要新实例
   - 要使用slice切片时，要追加互斥锁（写锁）,上锁=》append=》解锁.<font color="red">append操作扩容的话会改变切片变量的地址</font>，所以需要操作切片指针类型
4. errgroup缺点 只有一个error返回值 不能传参数, 只能使用闭包 <font color="red">error只会有一个协程报错时先赋值</font>
5. SetLimit(n) 能设置最大并发数, <font color="red">内部sem通道进行阻塞 挂起要调用的这个闭包，但是都已经启动了 只是挂在g.sem <- token{}步骤</font>

# 例子用法

## 超时控制例子
``` go
package main

import (
    "context"
    "fmt"
    "golang.org/x/sync/errgroup"
    "time"
)

func main() {
    // tag: 1. 创建一个带有取消信号的context  context.Background() 也可以是其他传递的上下文ctx
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel() // 这里的cancel是更上层的  errgroup.WithContext构造的时候 内部会派生withCancelCause

    // tag: 2. 通过errgroup.WithContext创建带有context的errgroup.Group
    // errgroup.Group结构体定义了一个用于管理goroutine的组，并包含一个sync.WaitGroup类型的成员变量wg用于等待所有goroutine完成。
    g, ctx := errgroup.WithContext(ctx)
    // g := new(errgroup.Group)   // 直接new 可以创建不携带超时ctx
    
    // tag: 3.  添加并发任务 
    // 创建一个新的goroutine，并在其中执行传入的函数。同时，它会使用sync.WaitGroup.Add(1)增加计数器，表示有一个goroutine正在执行。
    // 在Go()方法中，通过recover()函数捕获可能发生的panic，并将其转换为错误类型返回。因为是新起的一个协程
    g.Go(func() error {
        select {
        case <-ctx.Done(): // tag: 派生的context
            fmt.Println("任务1被取消")
            return ctx.Err()
        case <-time.After(2 * time.Second):
            fmt.Println("任务1完成")
            return nil
        }
    })

    g.Go(func() error {
        select {
        case <-ctx.Done():
            fmt.Println("任务2被取消")
            return ctx.Err()
        case <-time.After(3 * time.Second):
            fmt.Println("任务2完成")
            return nil
        }
    })

    // tag: 4.0 等待所有并发任务完成 通过sync.WaitGroup.Wait()来阻塞主线程，直到所有goroutine都完成。如果其中一个goroutine返回了错误，它会通过context对象取消其他正在执行的goroutine，并返回错误。
    if err := g.Wait(); err != nil {
        fmt.Println("任务执行出错:", err)
    } else {
        fmt.Println("所有任务执行完成")
    }
}
  ```

- 示例1：并发执行多个HTTP请求，并等待它们全部完成或任何一个请求返回错误。

```go
package main

import (
	"fmt"
	"net/http"

	"golang.org/x/sync/errgroup"
)

func main() {
	g := new(errgroup.Group)

	urls := []string{
		"http://example.com",
		"http://example.net",
		"http://example.org",
	}

	for _, url := range urls {
        // tag: for循环里使用go起新协程，协程里使用外部变量，会有竞争问题，所以要赋值给一个新变量
        // 要使用map，那么要使用 sync.Map去存放，要改变结构体成员属性，那么还是要新实例
        // 要使用slice切片时，要追加互斥锁（写锁）

		url := url // create a new variable to avoid the closure problem
		g.Go(func() error {
			resp, err := http.Get(url)
			if err != nil {
				return err
			}
			defer resp.Body.Close()
			// process the response
			return nil
		})
	}

	if err := g.Wait(); err != nil {
		fmt.Println("one of the requests returned an error:", err)
	}
}

``` 

# 源码解析
```go
package errgroup

import (
	"context"
	"fmt"
	"sync"
)

// 定义一个空结构体类型 token，会作为信号进行传递，用于控制并发数
type token struct{}
 
// tag: Group 是一组协程的集合，这些协程处理同一整体任务的子任务
// 零值 Group 是有效的，对活动协程的数量没有限制，并且不会在出错时取消
type Group struct {
    cancel func(error) // tag: 取消函数 context.CancelCauseFunc类型 初始化时调用withCancelCause赋值
    
    wg sync.WaitGroup // 内部使用了 sync.WaitGroup
    
    sem chan token // 信号channel，可以控制协程并发数量 (包含最大并发数)

    errOnce sync.Once // 确保错误仅处理一次
    err     error     // 记录子协程集中返回的第一个错误
}

// SetLimit 限制该 Group 中活动的协程数量最多为 n，负值表示没有限制
func (g *Group) SetLimit(n int) {
	if n < 0 {
		g.sem = nil // 小于 0 则不限制协程并发数量。此外，也不要将其设置为0，会产生死锁
		return
	}
    // 在 Group 中存在任何活动的协程时，限制不得修改 存在活动的协程，调用此方法将产生 panic
    // 所有要在调用 errgroup.Go 或 errgroup.TryGo 方法前调用
	if len(g.sem) != 0 {
		panic(fmt.Errorf("errgroup: modify limit while %v goroutines in the group are still active", len(g.sem)))
	}
	g.sem = make(chan token, n) // 设置一个有缓冲的channel通道, 模拟信号量的设计
}

// 当一个协程完成时，调用此方法
func (g *Group) done() {
    // 设置了最大并发数，则sem不为nil
	if g.sem != nil {
		<-g.sem // 从channel中消费一个token，表示一个协程已完成
	}
	g.wg.Done() // 转发给 sync.WaitGroup Done()，将活动协程数-1
}

// 使用的时候 要么 errgroup.New() 要么 errgroup.WithContext(ctx) 此ctx可以设置超时和cancel
// 返回一个新的 Group 和一个从ctx派生的关联Context ,派生的Context会在传递给 Go 的函数首次返回非 nil 错误或 Wait 首次返回时被取消，以先发生者为准
func WithContext(ctx context.Context) (*Group, context.Context) {
	ctx, cancel := withCancelCause(ctx)
    // 给cancel字段 赋值取消函数
	return &Group{cancel: cancel}, ctx 
}

// Wait 会阻塞，直到来自 Go 方法的所有函数调用返回
func (g *Group) Wait() error {
	g.wg.Wait() // sync.WaitGroup 的 Wait会阻塞
    
    // tag: 如果有设置取消函数 就调用 通过context中断其他协程
	if g.cancel != nil {
		g.cancel(g.err) // Wait 首次返回非nil错误, context取消 
	}

	return g.err // 错误传递通过 结构体的err字段
}

func (g *Group) Go(f func() error) {

    // 配置最大并发的情况
	if g.sem != nil {
		g.sem <- token{} // tag: 如果超过了配置的活跃协程数量限制，向 channel 发送 token 会阻塞
	}

	g.wg.Add(1) // 转发给 sync.WaitGroup Done()，将活动协程数+1
	go func() {
		defer g.done() // 当一个协程完成时，调用此方法 (如果有设置sem就消费chan，将活动协程数-1)
        // tag: f() 就是我们要执行的任务 
		if err := f(); err != nil {
            // tag: 出现错误的情况 sync.Once包 仅执行一次，即只处理一次错误，所以会记录第一个非 nil 的错误，与协程启动顺序无关
			g.errOnce.Do(func() {
				g.err = err // 错误赋值
                // tag: 如果有设置取消函数 就调用 通过context中断其他协程
				if g.cancel != nil {
					g.cancel(g.err) // 首次返回非nil错误, context取消
				}
			})
		}
	}()
}

// TryGo 仅在Group中活动的协程数量低于限额时，才能新的协程中调用给定的函数
// 返回值标识协程是否启动
func (g *Group) TryGo(f func() error) bool {
    // 设定最大并发数
	if g.sem != nil {
		select {
		case g.sem <- token{}: // 可以向 channel 写入 token，说明没有达到限额，可以启动协程
            // 不需要任何操作
		default:
			return false // 超过最大并发数 就返回false
		}
	}
    // 与Go方法一致
	g.wg.Add(1)
	go func() {
		defer g.done()

		if err := f(); err != nil {
			g.errOnce.Do(func() {
				g.err = err
				if g.cancel != nil {
					g.cancel(g.err)
				}
			})
		}
	}()
	return true
}

// 为低于 Go 1.20 版本提供的 withCancelCause 函数实现
package errgroup
import "context"

func withCancelCause(parent context.Context) (context.Context, func(error)) {
    return context.WithCancelCause(parent)
}
```

## 案例

```go
func TestErrgroup(t *testing.T) {
	start := time.Now()
	// 锁 或者并发安全的map
	var sliceLock sync.Mutex
	arrSlice := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	var result []int
	// 设置下顶层的超时时间 tag: 1*time.Second 和 2*time.Second 的区别; 错误优先赋值
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
	// ctx, cancel := context.WithCancel(context.Background())

	defer cancel()
	eg, gCtx := errgroup.WithContext(ctx)
	eg.SetLimit(3) // tag: 最大并发数 这样就不使用信号量或channel

	for pos, v := range arrSlice {
		tmpPos := pos
		tmpVal := v

		// tag: 本身使用eg.Go方法就已经进入 内置的工作组了
		eg.Go(func() error {
			// tag: 内部sem通道进行阻塞 挂起要调用的这个闭包，但是都已经启动了 只是挂在g.sem <- token{}步骤
			select {
			case <-ctx.Done():
				fmt.Printf("上层超时, pos:%d, 任务取消 err:%+v \n", tmpPos, ctx.Err())
				return ctx.Err() // tag: 上层设置超时时间后， 会抛出context deadline exceeded 父级的上下文错误应该外抛 比较合理 此时gCtx.Err()也为context deadline exceeded了
			case <-gCtx.Done(): // tag: 派生的context对应通道收到消息 或者其他上级ctx cancel和超时
				fmt.Printf("pos:%d, 任务取消 err:%+v \n", tmpPos, gCtx.Err())
				return gCtx.Err() // 此时为取消的情况 gCtx.Err()为context canceled 常量context.Canceled 超时错误是否外抛自己控制,
				// tag: 此时返回错误没用，因为err在errgroup只会记录一次, 这个就是协程超时或取消收到的消息
			// case <-time.After(1 * time.Second): // 本身协程的控制
			// 	fmt.Printf("pos:%d, 任务提前完成\n", tmpPos)
			// 	return nil
			default:
				// tag: 思考 result为啥要用 *[]int
				fmt.Printf("pos:%d,val:%v 任务调用errProcessDealV2 \n", tmpPos, tmpVal)
				err := errProcessDealV2(tmpPos, tmpVal, &sliceLock, &result)
				//  context.Canceled 超时错误是否外抛自己控制
				if err != nil {
					return err // tag: 执行异常了 返回err就会终止其他（这个时候通过select监听gCtx）
				}

				return nil
			}
		})
	}

	if err := eg.Wait(); err != nil {
		fmt.Println("整体任务执行出错:", err)
	}
	spew.Printf("result:%+v \n", result) // result:<nil> 的什么情况下会发生
	// 正常情况 result:[4 2 6 8 10 ....]

	// tag: 中间任务抛下err 初始化时是3个最大并发数
	// pos:2,val:3 任务调用errProcessDealV2
	// pos:1,val:2 任务调用errProcessDealV2
	// pos:0,val:1 任务调用errProcessDealV2
	// pos:5,val:6 任务调用errProcessDealV2
	// pos:3,val:4 任务调用errProcessDealV2
	// pos:4,val:5 任务调用errProcessDealV2
	// pos:6, 任务取消 err:context canceled
	// pos:7, 任务取消 err:context canceled
	// pos:8, 任务取消 err:context canceled
	// 整体任务执行出错: pos为5时特意抛出错误
	// result:[2 4 6 8 10]
	// 程序执行耗时(s): 4.002710375

	// tag: 如果父级超时  到挂起的协程轮到时，此时顶层上下文的已经触发超时了
	// pos:2,val:3 任务调用errProcessDealV2
	// pos:0,val:1 任务调用errProcessDealV2
	// pos:1,val:2 任务调用errProcessDealV2
	// 上层超时, pos:5, 任务取消 err:context deadline exceeded
	// 上层超时, pos:4, 任务取消 err:context deadline exceeded
	// pos:6, 任务取消 err:context deadline exceeded
	// 上层超时, pos:3, 任务取消 err:context deadline exceeded
	// pos:7, 任务取消 err:context deadline exceeded
	// pos:8, 任务取消 err:context deadline exceeded
	// 整体任务执行出错: context deadline exceeded // tag: 此时这个上级的抛错速度更快(又因为只会赋值一次)
	// result:[4 6 2]
	// 程序执行耗时(s): 2.001787625
	// PASS

	end := time.Now()
	consume := end.Sub(start).Seconds()
	fmt.Println("程序执行耗时(s):", consume)
}

func errProcessDealV2(pos int, val int, mu *sync.Mutex, res *[]int) error {
	if pos == 5 {
		return errors.New("pos为5时特意抛出错误") // 故意制造的业务报错
	}
	time.Sleep(2 * time.Second)
	// 并发安全需要保证
	mu.Lock()
	// fmt.Printf("[errProcessDealV2]pos:%d,val:%v lock \n", pos, val)
	*res = append(*res, val*2) // tag: 切片是“引用类型”，但 append 可能会返回新切片 所以需要指针
	mu.Unlock()
	// 有上下文超时的错误
	return nil
}
```