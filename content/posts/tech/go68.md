---
title: "IM系统" #标题
date: 2025-12-11T15:05:08+08:00 #创建时间
lastmod: 2025-12-11T15:05:08+08:00 #更新时间
author: ["citybear"] #作者
categories: # 没有分类界面可以不填写
- tech
tags: # 标签
- web技术
keywords: 
- 
description: "" #描述 每个文章内容前面的展示描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true #是否展示评论 有自带的扩展成twikoo
showToc: true # 显示目录 文章侧边栏toc目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
    image: "" #图片路径：posts/tech/文章1/picture.png
    caption: "" #图片底部描述
    alt: ""
    relative: false

# reward: true # 打赏
mermaid: true #自己加的是否开启mermaid
---

# IM系统

goim 是一个支持集群的im及实时推送服务（支持websocket，http和tcp协议）用于B站生产线上的IM服务框架（聊天室）

- https://www.bilibili.com/video/av54096240/ 
- https://github.com/developer-learning/reading-go/issues/363

# 相关笔记
- [【有道云笔记】IM消息（微信 tq企业）](https://share.note.youdao.com/s/KWZ6HZWK)


# 长链接管理 mp-im-socket
- Golang实现，比较轻量，快速部署，快速扩容
- 可拓扑的架构，节点可以无限扩展
- 通讯协议：websocket，双向通信，性能高，容易调试
- 框架：基于socket.io库开发

## 整体架构
### 模块功能
![alt text](image1.png)

### 架构拓扑
![alt text](image2.png)
- 首先客户端通过接口拉取slb的ip列表。然后通过 ip-hash 的方式负载均衡到各个 comet 节点，comet 节点不保存任何状态，状态均存在 redis 集群中。按照这个结 构，comet 节点可以无限制部署
  - 两个极限，一个是slb的链接瓶颈，另一个是 redis 的瓶颈，这两个都可以通过扩容来实现。

## 用户服务
### 用户登录
![alt text](image3.png)
存在问题：用户被目前是通过ticket_id来判断用户身份，存在被盗用的风险。

### 如何维护用户在线状态：
由于IM是长链接，运营商对空闲的NAT会进行回收，为了防止被运营商杀掉长链接，所以需要发送一段很小的报文告 诉对方“我还活着”。心跳包的频率过长，长链接容易被杀死，过短则手机增加耗电。 目前IM实现是，客户端每隔20s，发送心跳报文ping，IM收到报文回复pong给客户端，如果三次都没收到心跳，则认 定为离线。所以app异常退出有时候需要1分钟才可以知道离线。

## 房间服务
- 房间在im模块是个虚拟的 业务的房间进行映射的点，如果comet节点上没有相关的房间 消息也不会订阅（只有多人聊天才会用到房间）
### 加入房间
![alt text](image4.png)
- 保证大主播房间消息
  - 用户加入一个直播间，IM会根据用户所在comet节点，在相应的节点上创建虚拟房间。同一个房间可能分布在不同的 comet节点。可以避免某个大主播的房间在同一个节点，导致那个节点宽带被打满。

### 房间消息下发
![alt text](image5.png)

- 如何保证消息实时性
  1. 利用redis pub消息，redis和im是长链接实时sub消息，监听频道可以多个利用集群特性分散节点 
  2. 每个用户下发都单独消息缓存队列，并且单独一个协程处理，单用户消息卡也不会影响其他用户 
  3. 用户如果消息过多超过阈值，根据消息优先级，丢掉一些优先级低的消息。消息优先级（丢弃某些不重要消息）
    - 直播业务里，消息合并 丢弃可以放到im模块 也可以放到业务逻辑里
    - 每个用户都有消息N, 暂时放到内存里，当检测到消息堆积过多，就会进行消息分级 合并 丢弃等操作

- 如何降低IM下行带宽等
  - 现状：房间多，同时有几千个聊天室在开播，聊天室内需要同步很多信息给客户端（在线列表，麦位信息等）
  - 之前的做法，每个房间每隔三秒下发房间全量属性信息， 
  - 改进之后，将每个房间的状态分类，有变更则下发给客户端，客户端收到后回执给IM

## 私信服务
![alt text](image6.png)
- 私信消息可靠性保证： 
  - 为了保证消息不丢失，IM私信模块引入了ACK和三次重试机制。IM下发私信消息给客户端，客户端收到会发一条ack 回执给IM，不然IM会重试发送。超过3次没收到回执，则认定客户端离线，通过推送来通知用户，并且推到消息未读队列，（业务消费该队列存到mysql表），下次客户端在线通过接口拉取。

- 如何保证消息id唯一性和有序性： 
  - 消息id贯穿整个私信系统，弱网环境下一条消息有可能会收到多次，客户端需要去重，所以需要保证消息id唯一性， 目前消息id是由业务方创建的随机字符串。 消息发送前后顺序要保证，没办法通过消息id来排序，故每条消息带上时间戳，用时间戳来排序。
  
## 遇到的坑
1. 迁移到k8s的时候，服务器ip没有对应修改成pod的ip，重复订阅私信消息，导致私信重复下发
2. im和业务端是用MQ作为消息总线，但是IM节点内部用的是redis的订阅。如果redis挂掉，则私信会丢失

# 配合tq企业中台项目
- 在线消息
![alt text](image7.png)
- 离线消息
![alt text](image8.png)

## 私信流程图

![alt text](image9.png)
``` 
sequenceDiagram
    participant A as 客户端A(发送方)
    participant GW as API网关
    participant MSG as 消息服务
    participant DB as 消息数据库
    participant WS as 长连接网关
    participant B as 客户端B(接收方)
    participant MQ as 消息队列
    participant OS as 离线存储
    
    rect rgba(200, 223, 255, 0.5)
    note right of A: 消息发送阶段
    A->>GW: 1. 发送消息请求<br>(消息内容+接收方ID)
    GW->>MSG: 2. 认证鉴权<br>请求转发
    MSG->>MSG: 3. 生成消息ID<br>
    MSG->>DB: 4. 消息持久化存储<br>
    MSG->>MQ: 5. 写入消息队列<br>(MQ)
    end
    
    rect rgba(200, 255, 223, 0.5)
    note right of MSG: 实时推送阶段
    alt 接收方在线
        MSG->>WS: 6. 查询在线状态<br>(Redis)
        WS->>B: 7. WebSocket推送<br>
        B->>WS: 8. 消息接收ACK
        WS->>MSG: 9. 确认送达
        MSG->>DB: 10. 更新状态为"已送达"
        B->>B: 11. 本地存储消息
        B->>WS: 12. 用户阅读后发送已读回执
        WS->>MSG: 13. 转发已读回执
        MSG->>DB: 14. 更新状态为"已读"
        MSG->>A: 15. 通知发送方消息状态更新
    else 接收方离线
        MSG->>OS: 6a. 存入离线消息存储
        loop 定时检查
            B->>GW: 6b. 上线通知
            GW->>MSG: 检查离线消息
            MSG->>OS: 查询离线消息
            OS->>MSG: 返回未读消息
            MSG->>B: 批量推送离线消息
            B->>MSG: 确认接收
            MSG->>OS: 删除已推送消息
        end
    end
end

```

## 表设计
私信 历史表 msg_history 
按月分表，并且每个月500张表 （表名字如：msg_history_202209_0，msg_history_202209_1 ）
路由规则：根据 conversation_id  hash%500
``` sql
CREATE TABLE `msg_history_202209_0` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增id',
  `conversation_id` varchar(40) NOT NULL COMMENT '会话ID',
  `receiver_uuid` varchar(32) NOT NULL COMMENT '接收方用户uuid',
  `sender_uuid` varchar(32) NOT NULL COMMENT '发送方用户uuid',
  `msg_id` varchar(32) NOT NULL COMMENT '消息id',
  `conversation_type` tinyint(4) DEFAULT NULL COMMENT '会话类型 private_msg',
  `content_type` varchar(32) DEFAULT NULL COMMENT '消息内容类型',
  `content` text COMMENT '消息内容',
  `extra` text COMMENT '消息额外内容',
  `account1_delete` varchar(32) DEFAULT NULL,
  `account2_delete` varchar(32) DEFAULT NULL,
  `app_code` int(11) DEFAULT NULL COMMENT '应用版本号',
  `tag1` tinyint(4) DEFAULT NULL COMMENT '消息标记',
  `status` tinyint(2) NOT NULL DEFAULT '0' COMMENT '0:已经发送go; 1:已经接受回调用',
  `create_time` bigint(14) NOT NULL DEFAULT '0' COMMENT '创建时间',
  `modify_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `msg_id` (`msg_id`),
  KEY `idx_conversation_id` (`conversation_id`) USING BTREE,
  KEY `create_time` (`create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='历史消息表';
```

私信离线表 msg_offline
按月分表，并且每个月32张表 （表名字如：msg_offline_202302_0，msg_offline_202302_1 ）
路由规则：根据 target_uuid  hash%32
``` sql
CREATE TABLE `msg_offline_202302_0` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '自增id',
  `conversation_id` varchar(40) NOT NULL COMMENT '会话ID',
  `receiver_uuid` varchar(32) NOT NULL COMMENT '接收方用户uuid',
  `sender_uuid` varchar(32) NOT NULL COMMENT '发送方用户uuid',
  `msg_id` varchar(32) NOT NULL COMMENT '消息id',
  `conversation_type` tinyint(4) NOT NULL COMMENT '会话类型',
  `content_type` varchar(32) NOT NULL COMMENT '消息内容类型',
  `content` text COMMENT '消息内容',
  `extra` text COMMENT '消息额外内容',
  `app_code` int(11) DEFAULT NULL COMMENT '应用版本信息',
  `create_time` bigint(14) NOT NULL DEFAULT '0' COMMENT '创建时间',
  `modify_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
  `is_deleted` tinyint(4) unsigned NOT NULL DEFAULT '0' COMMENT '是否删除，1-删除，0-有效',
  `target_uuid` varchar(32) NOT NULL COMMENT '目标targetuuid',
  PRIMARY KEY (`id`),
  UNIQUE KEY `msg_id_target_uuid` (`msg_id`,`target_uuid`),
  KEY `receiver_uuid` (`receiver_uuid`),
  KEY `create_time` (`create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='离线消息表';
```

会话表 private_msg_conversation 使用hbase
分为32张表（表名字如：private_msg_conversation_0，private_msg_conversation_1 ）
路由规则：根据 conversation_id  hash%32
``` sql
CREATE TABLE `private_msg_conversation_1` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `conversation_id` varchar(50) NOT NULL COMMENT '会话id',
  `account_uuid1` varchar(20) NOT NULL COMMENT '关联用户uuid1',
  `account_uuid2` varchar(20) NOT NULL COMMENT '关联用户uuid2',
  `account_uuid1_read_time` bigint(14) DEFAULT NULL COMMENT 'uuid1的会话阅读时间戳， 做已读未读功能',
  `account_uuid2_read_time` bigint(14) DEFAULT NULL COMMENT 'uuid2的会话阅读时间戳， 做已读未读功能',
  `app_code` int(11) DEFAULT NULL COMMENT '应用版本信息',
  `create_time` bigint(14) NOT NULL COMMENT '创建时间',
  `modify_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `conversation_id` (`conversation_id`) USING BTREE,
  KEY `create_time` (`create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='私信会话';
```

msg_system_all私信系统消息

## api接口
https://o15vj1m4ie.feishu.cn/wiki/wikcn7Fz7G7usnNI2P3GFLGJcPb