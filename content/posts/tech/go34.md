---
title: "Go-数据库gorm包" #标题
date: 2024-01-10T14:07:38+08:00 #创建时间
lastmod: 2024-01-10T14:07:38+08:00 #更新时间
author: ["citybear"] #作者
categories: # 没有分类界面可以不填写
- tech
tags: # 标签
- go基础
- go包
- go源码
keywords: 
- 
description: "" #描述 每个文章内容前面的展示描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true #是否展示评论 有自带的扩展成twikoo
showToc: true # 显示目录 文章侧边栏toc目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
    image: "" #图片路径：posts/tech/文章1/picture.png
    caption: "" #图片底部描述
    alt: ""
    relative: false

# reward: true # 打赏
mermaid: true #自己加的是否开启mermaid
---

# 源码解析

1. [Golang sql 标准库源码解析](https://mp.weixin.qq.com/s?__biz=MzkxMjQzMjA0OQ==&mid=2247484727&idx=1&sn=a05080a9494438c0fa57c92b9f159d55&chksm=c10c4be9f67bc2ff48b37fe80215f55f2338b700f55896ff2452dc183464c025695f2d272620&scene=21#wechat_redirect)
2. [Golang mysql 驱动源码解析](https://mp.weixin.qq.com/s?__biz=MzkxMjQzMjA0OQ==&mid=2247484744&idx=1&sn=d315ce9c80a502a35677595638d450bb&chksm=c10c4b96f67bc2806947de5e528383bb81471f3b8be5b27796d6dc2f030d7bf5ed02145ae077&scene=21#wechat_redirect )
3. [gorm 框架源码解析](https://mp.weixin.qq.com/s/STFnyke1NX8Ag8COlHwaLA)

![alt text](image1.png)

# 快速入门
- [官方文档](https://learnku.com/docs/gorm)
- [李文周gorm-crud](https://www.liwenzhou.com/posts/Go/gorm-crud/ )

- GORM 使用 database/sql 维护连接池
- 支持context
- 支持多数据库，配置不同的驱动就行

# 其他封装包
[sqlx+squirrel](https://www.ab62.cn/article/17302.html)
mattermost的store/sqlstore模块
# 如何处理高并发 go.DB
b站有个视频

# 如何使用
## 容器环境

基于 bitnami/mysql docker容器（主从集群等配置具体看说明书）, 进行测试-本地数据库

1. docker pull bitnami/mysql:8.0.19
![alt text](image2.png)

2. 软件直连或者客户端
```
docker run -it --network host --rm bitnami/mysql:8.0.19 mysql -h127.0.0.1 -P13306 --default-character-set=utf8mb4 -uroot -p
```
![alt text](image3.png)


## 驱动(不同数据库)
GORM已经贴心的为我们包装了一些驱动程序，只需要按如下方式导入需要的数据库驱动即可 (mysql sqlite3 clickhouse，postgres)
``` 
gorm.io/driver/mysql
gorm.io/driver/clickhouse
```

## 链接配置gorm.Config与db实例的创建gorm.Open
1. 设置好连接 mysql 的 dsn（data source name）
   - 设置 dsn 时，建议添加上<font color="red"> parseTime=true </font>的设置，这样能兼容支持将 mysql 中的时间解析到 golang 中的 time.Time 类型字段
  - 设定字符集时，<font color="red">建议使用 uft8mb4 替代 utf8</font>，这样能支持更广泛的字符集，包括表情包等特殊字符的存储
  - 时区等
2. 通过 gorm.Config 完成 db 有关的自定义配置<font color="red">（事务 超时 日志 连接池 监控插件prometheus）</font>
3. 通过 gorm.Open 方法完成 db 实例的创建
   - 创建 gorm.DB 实例时，默认情况下会向数据库服务端发起一次连接，以保证 dsn 的正确性.
   - <font color="red">DB 对象是绝对的核心，基本所有操作都是围绕着这个 DB 实例展开的，大量通过使用 DB 进行链式调用的代码风格</font>

- 简单的链接
``` go
func TestEasy(t *testing.T) {
    source := "root:citybear@(127.0.0.1:13306)/mydata" // 账号：密码 ip端口 数据库名
    dsn := fmt.Sprintf("%s?charset=utf8mb4&readTimeout=%ds&writeTimeout=%ds&parseTime=True&loc=Local", source, 3, 3)
    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
        SkipDefaultTransaction: true, // 事务
    })
    if err != nil {
        panic(err)
    }
    fmt.Printf("数据库资源%#v", db)
}

```
- 复杂配置
``` go
// NewMysqlDbByGorm 实例化gorm
func NewMysqlDbByGorm(config *conf.Mysql) (*gorm.DB, error) {
    // 参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name 获取详情
    // dsn := "user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&parseTime=True&loc=Local"
    // "source": "root:1234@tcp(127.0.0.1:3306)/test"
    dsn := fmt.Sprintf("%s?charset=utf8mb4&parseTime=True&loc=Local", config.Source)

    readTimeout := 3
    if config.ReadTimeout > 0 {
        readTimeout = config.ReadTimeout
    }
    dsn += fmt.Sprintf("&readTimeout=%ds", readTimeout)

    writeTimeout := 3
    if config.WriteTimeout > 0 {
        writeTimeout = config.WriteTimeout
    }
    dsn += fmt.Sprintf("&writeTimeout=%ds", writeTimeout)
    
    opt := &gorm.Config{
        SkipDefaultTransaction: true, // 关掉默认事务
        //QueryFields:            true, // 打开字段查询
    }
    if util.IsDev() {
        // 本地开发环境日志全部打出来
        opt.Logger = logger.Default.LogMode(logger.Info)
    } else {
        logType := logger.Error
        switch conf.Conf.Server.Log.LogLevel {
        case "debug", "info":
            logType = logger.Info
        case "warn":
            logType = logger.Warn
        }
        opt.Logger = logger.New(
            logWriter{},
            logger.Config{
                SlowThreshold:             50 * time.Millisecond, // Slow SQL threshold
                LogLevel:                  logType,               // Log level
                IgnoreRecordNotFoundError: true,                  // Ignore ErrRecordNotFound error for logger
                Colorful:                  false,                 // Disable color
            },
        )
    }
    DB, err := gorm.Open(mysql.Open(dsn), opt)
    if err != nil {
        panic(err)
    }

    // 连接池
    sqlDB, err := DB.DB()
    if config.MaxOpenConn > 0 {
        sqlDB.SetMaxOpenConns(config.MaxOpenConn) // 设置数据库连接池最大连接数
    }
    if config.MaxIdleConn > 0 {
        sqlDB.SetMaxIdleConns(config.MaxIdleConn) // 连接池最大允许的空闲连接数，如果没有sql任务需要执行的连接数大于100，超过的连接会被连接池关闭。
    }

    if config.MaxLifeTime > 0 {
        sqlDB.SetConnMaxLifetime(time.Duration(config.MaxLifeTime) * time.Second) // SetConnMaxLifetime 设置了连接可复用的最大时间
    }

    refreshInterval := 15
    if conf.IsOnline() {
        refreshInterval = 60 * 10
    }

    // metrics
    DB.Use(prometheus.New(prometheus.Config{
        DBName:          "admp",
        RefreshInterval: uint32(refreshInterval),
        MetricsCollector: []prometheus.MetricsCollector{
            &prometheus.MySQL{VariableNames: []string{"Threads_running"}},
        },
    }))

    return DB, err
}
```

- clickhouse
``` go
// NewClickhouseClient clickhouse实例
func NewClickhouseClient(config *conf.Clickhouse) *gorm.DB {
    dsn := fmt.Sprintf("clickhouse://%s:%s@%s:%d/%s", config.Username, config.Password, config.Host, config.Port, config.Database)
    db, err := gorm.Open(clickhouse.Open(dsn), &gorm.Config{})
    if err != nil {
        panic(err)
    }
    return db
}
```

## 配置项的字段
``` go
type Config struct {
    // gorm 中，针对单笔增、删、改操作默认会启用事务. 可以通过将该参数设置为 true，禁用此机制
    SkipDefaultTransaction bool
    // 表、列的命名策略
    NamingStrategy schema.Namer
    // 自定义日志模块
    Logger logger.Interface
    // 自定义获取当前时间的方法
    NowFunc func() time.Time
    // 是否启用 prepare sql 模板缓存模式
    PrepareStmt bool
    // 在 gorm 创建 db 实例时，会创建 conn 并通过 ping 方法确认 dsn 的正确性. 倘若设置此参数，则会禁用 db 初始化时的 ping 操作
    DisableAutomaticPing bool
    // 不启用迁移过程中的外联键限制
    DisableForeignKeyConstraintWhenMigrating bool
    // 是否禁用嵌套事务
    DisableNestedTransaction bool
    // 是否允许全局更新操作. 即未使用 where 条件的情况下，对整张表的字段进行更新
    AllowGlobalUpdate bool
    // 执行 sql 查询时使用全量字段
    QueryFields bool
    // 批量创建时，每个批次的数据量大小
    CreateBatchSize int
    // 条件创建器
    ClauseBuilders map[string]clause.ClauseBuilder
    // 数据库连接池
    ConnPool ConnPool
    // 数据库连接器
    Dialector
    // 插件集合
    Plugins map[string]Plugin
    // 回调钩子
    callbacks  *callbacks
    // 全局缓存数据，如 stmt、schema 等内容
    cacheStore *sync.Map
}
```

## 预定义Modle
``` go
package gorm
type Model struct {
    // 主键 id
    ID        uint `gorm:"primarykey"`
    // 创建时间
    CreatedAt time.Time
    // 更新时间
    UpdatedAt time.Time
    // 删除时间
    DeletedAt DeletedAt `gorm:"index"`
}
```
-  gorm 体系中，一个 po 模型<font color="red">只要启用了 deletedAt 字段，则默认会开启软删除机制</font>：在执行删除操作时，不会立刻物理删除数据，而是仅仅将 po 的 deletedAt 字段置为非空

## gorm标签
![alt text](image4.png)

## 指定表名
``` go
// 声明 TableName 方法来指定其对应的表名
func (p PO) TableName() string {
    return "xxxTable"
}

// 操作 gorm.DB 实例时通过 Table 方法, 分表的时候需要这种方案
db = db.Table("xxxTable")
```

## 字段零值问题

- <font color="red">字段在初始化时也会首先赋上零值</font>, 执行创建、更新等操作时，倘若 po 模型中存在零值字段，此时 gorm 无法区分到底是用户显式声明的零值，还是未显式声明而被编译器默认赋予的零值<font color="red">(默认这种未显式声明，不更新)</font>

- 创建时，零值字段也是不会保存到数据库内，但会使用他们的默认值（ddl设置的）

1. 使用指针类型, 只要指针非空，就代表使用方进行了显式赋值.
``` go
type PO struct{
   gorm.Model
   Age *int `gorm:"column:age"` // 默认值为 18
}
```

1. 使用 sql.Nullxx 类型, Valid 标识为 true，就代表使用方进行了显式赋值. 实现 Scanner/Valuer 接口
``` go
type PO struct{
   gorm.Model
   Age sql.NullInt64 `gorm:"column:age"` // 默认值为 18
}
type NullInt64 struct {
    Int64 int64
    Valid bool // Valid is true if Int64 is not NULL
}
```

1. Updates+Map, **<font color="red">Updates的参数不使用结构体，使用map[string]any </font> **
    - 结构体modle情况
![alt text](image6.png)
    - map情况
![alt text](image5.png)
   - Model(某模型结构体) 也是为了指定表名，可以直接Table
   - Save + Select 也是一种方案，不如Updates, <font color="red">Save会保存整个struct的值</font>

## 支持context
``` go
// 超时控制 5s
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)    
defer cancel()
// 批量创建时会根据 gorm.Config 中的 CreateBatchSize 进行分批创建操作    
resDB := db.WithContext(ctx).Table("po").Create(&pos)
// 创建完后的 主键id，可以直接结构体实例取 pos.Id, 所以采用&
```
## 注意细节

1. <font color="red">立即执行方是指那些会立即生成SQL语句并发送到数据库的方法</font>, 他们一般是CRUD方法，比如：Create, First, Find, Take, Save, UpdateXXX, Delete, Scan, Row, Rows.<font color="red">在调用立即执行方法前不会生成Query语句，借助这个特性你可以创建一个函数来处理一些通用逻辑。（公共条件sql）</font>

2. 不存在就新建，考虑直接使用 FirstOrCreate 直接创建记录了
``` go
    // 考虑直接使用 FirstOrCreate 仅支持 struct 和 map 条件
    // 当通过结构体进行查询时，GORM将会只通过非零值字段查询，这意味着如果你的字段值为0，''，false或者其他零值时，将不会被用于构建查询条件
    info := &models.MediaTagList{}
    err := db.Where(models.MediaTagList{MediaCode: mediaCode, TagName: tagName}).Attrs(models.MediaTagList{Operator: operator}).FirstOrCreate(info).Error
    if err != nil {
        return nil, err
    }
    tagId := info.ID
``` 

3. Attrs方法和Assign方法。 必须是struct（map不行）
   - 配合Attrs 如果记录未找到，将使用参数初始化 struct
   - Assign 不管记录是否找到，都将参数赋值给 struct

4. 当内联条件与多个立即执行方法一起使用时, 内联条件不会传递给后面的立即执行方法。就是执行方法里 携带的条件 db.Find(&user, "name = ?", "jinzhu")

5. 为查询 SQL 添加额外的 SQL 操作
``` go
// SELECT * FROM users WHERE id = 10 FOR UPDATE;
db.Set("gorm:query_option", "FOR UPDATE").First(&user, 10)
```

## 创建Create

- 创建 po 实例
- po <font color="red">模型已声明了 TableName 方法，用于关联数据表</font>
- 链式操作 DB，Create 方法传入 po 指针，完成创建
- 通过 DB.Error 接收返回的错误
- 通过 DB.RowsAffected 获取影响的行数
- <font color="red">由于传入的 po 为指针，创建完成后，po 实例会更新主键信息</font>

1. 支持批量 传入实例 <font color="red">改为实例切片 (批量创建时会根据 gorm.Config 中的 CreateBatchSize 进行分批创建操作)</font>
2. 使用 CreateInBatches 方法，可以通过在入参中显式指定单个批次创建的数据量上限
``` go
pos := []PO{
    {Age: &age1},
    {Age: &age2},
}

resDB := db.WithContext(ctx).Table("po").Create(&pos)
// resDB := db.WithContext(ctx).Table("po").CreateInBatches(&pos, len(pos))
t.Logf("rows affected: %d", resDB.RowsAffected)
// 打印各 po，输出其主键
for _, po := range pos {
    t.Logf("po: %+v\n", po) // po.Id
}
```

## 保存-冲突创建或更新 Clauses,clause.OnConflict
upsert，指的是数据<font color="red">如果不存在则创建，倘若存在，则按照预定义的策略执行更新操作. 一般2种策略</font>
-  结构体里的条件字段
-  结构体里的更新字段
-  可以处理批量数据

``` go
// 冲突时忽略
func Test_db_upsert(t *testing.T) {
    // 批量数据
    pos := []PO{
        //...
    }
    // 批量插入，倘若发生冲突 （id主键），则直接忽略执行该条记录
    // INSERT INTO `po` ... ON DUPLICATE KEY UPDATE `id` = `id`
    resDB := db.WithContext(ctx).Clauses(
        clause.OnConflict{
            Columns:   []clause.Column{{Name: "id"}}, // 条件
            DoNothing: true, // 创建时条件冲突就忽略
        },
    ).Create(&pos)
}

// 冲突则 更新指定字段
func Test_db_upsert(t *testing.T) {
    pos := []PO{
        //...
    }
    // 批量插入，倘若发生冲突（id主键），则将 age 更新为新值
    // INSERT INTO `po` ... ON DUPLICATE KEY UPDATE `age` = VALUES(age)
    resDB := db.WithContext(ctx).Clauses(
        clause.OnConflict{
            Columns:   []clause.Column{{Name: "id"}}, // 结构体里的条件字段
            DoUpdates: clause.AssignmentColumns([]string{"age"}),
        },
    ).Create(&pos)
}

// 比如
func (r *QqReport) BatchInsertGroupCSiteDay(ctx context.Context, data []*models.QqGroupCSiteDayReport) error {
    if len(data) == 0 {
        return nil
    }
    // r.data.db 指的就是gorm.Db实例 r.data.admpDb
    err := r.data.db.Table(r.groupCSiteDayTableName()).WithContext(ctx).Clauses(clause.OnConflict{
        Columns:   []clause.Column{{Name: "stat_date"}, {Name: "csite"}, {Name: "aid"}},
        DoUpdates: clause.AssignmentColumns([]string{"cost"}),
    }).Create(&data).Error
    return err
}
```

## 删除 Delete Unscope
1. 单条删除（没where条件），显示指定go.Model的ID
2. <font color="red">批量删除 带上where条件, 配合limit条件指定数量</font>
3. 软删除
   - 启用了 DeletedAt 字段的话，会启用软删除机制.Delete 方法只会把 DeletedAt 字段置为非空，**设为删除时的时间戳**，后续在查询和更新操作时，<font color="red">默认都会带上【 WHERE deleted_at IS NULL】的条件，保证这部分软删除的数据是不可见的.</font>
   - 获取到这部分软删除状态的数据，可以在<font color="red"> 带上 Unscope 标识</font>, 同理删除时带上也会变成物理删除
4. 物理删除, 未启用 DeletedAt 字段时，执行的 Delete 操作都是物理删除.
``` go
db.Unscope().WHERE("id = ?",1).Find(&po)
db.Unscope().Delete(&po)
```

## 增量更新（PATCH） Updates
1. 无where条件时

增量更新用户显式声明部分的字段，<font color="red">没有 where 条件，最终抛出 gorm.ErrMissingWhereClause 的错误</font>
在没有限定 where 条件的情况下，支持 updates 操作是非常危险的，这意味着会对整张表执行更新操作，因此默认情况下 gorm 会限制这种行为

- 方式 I：在 gorm.Config 中将 AllowGlobalUpdate 参数设为 true
- 方式 II：开启一个 session 会话，临时将 AllowGlobalUpdate 参数设为 true
``` go
    // 开启一个会话，将全局更新配置设为 true    
    dbSession := db.Session(&gorm.Session{        
        AllowGlobalUpdate: true,    
    })
```
1. 支持链式limit方法
2. 更新时支持通过 Select 或者 Omit 语句，来选定或者忽略指定的列（显示声明部分字段再进一步筛选，再更新）
``` go
    // 限定只更新 age 字段
    // UPDATE `po` SET age = 0 WHERE age > 10
    resDB := db.WithContext(ctx).Where("age > ?", 10).Select("age").Updates(&PO{
        Age:  &age,
        Name: &name,
    })
```

1. 表达式更新 UpdateColumn, gorm.Expr
``` go
// UPDATE `po` SET age = age * 2 + 1 WHERE id = 1 
resDB := db.WithContext(ctx).Table("po").Where("id = ?", 1)
.UpdateColumn("age", gorm.Expr("age * ? + ?", 2, 1))  
```

1. json列更新 UpdateColumn, datatypes.JSONSet

字段是json类型 mysql5.8后支持json. 针对 json 类型的列执行更新操作时，可以<font color="red">使用 gorm.io/datatypes包</font>中封装的相关方法
``` go
// UPDATE `po` SET extra = json_insert(extra,"$.key","value") WHERE id = 1    
resDB := db.Where("id = ?", 1).UpdateColumn("extra", datatypes.JSONSet("extra").Set("key", "value"))
```

## 全量保存（PUT） Save 方法
- Save 方法对应的是全量保存的语义，指的是会对整个 po 模型的数据进行溢写存储，<font color="red">即便其中有些未显式声明的字段，也会被更新为零值.</font>
- Save 方法需要慎用，<font color="red">通常是先通过 query 方法查到数据并进行少量字段更新后，再调用 Save 方法进行保存</font>

## 单条查询
- First、Last、Take倘若未查询到指定记录，则会**报错 gorm.ErrRecordNotFound**

分别是：返回满足条件的第一条数据记录，指的是主键最小的记录；最大记录，随机记录（没有order by）
``` go
err := db.First(&user, 100).Error
errors.Is(err, ErrRecordNotFound) // 建议

// 设置忽略错误
if err != nil && err != gorm.ErrRecordNotFound {
    return nil
}
```

- <font color="red">Find 即便没有查到指定记录，也不会返回错误.</font> 查询时可以通过 Select 方法声明只返回特定的列

## 批量查询
1. Find 方法还可以应用于批量查询，根据参数是模型还是模型切片
2. Scan 与 Find 的区别在于，<font color="red">使用时必须显式指定表名Table</font>
3. Pluck 方法实现<font color="red">批量查询指定列的操作</font> Pluck("字段名", 该字段类型切片)
``` go
var pos []PO    
// SELECT * FROM `po` WHERE age > 1 AND deleted_at IS NULL      
db.WithContext(ctx).Table("po").Where("age > ?", 1).Scan(&pos); // 多了Table

db.WithContext(ctx).Where("age > ?", 1).Find(&pos).Error;

 var ages []int64    
 // SELECT age from `po` WHERE age > 1 AND deleted_at IS NULL     
db.WithContext(ctx).Table("po").Where("age > ?", 1).Pluck("age", &ages) // t提取指定列
```

4. json类型字段 datatypes.JSONQuery

``` go
    // josn字段kv对
    var pos []PO
    // SELECT * FROM `po` WHERE json_extract("extra","$.key") = "value" AND deleted_at IS NULL 
    if err := db.WithContext(ctx).Table("po").Where(datatypes.JSONQuery("extra").Equals("value", "key")).Find(&pos).Error; err != nil {
        t.Error(err)
        return
    }
    // json指定key
    // SELECT * FROM `po` WHERE json_extract("extra","$.key") IS NOT NULL AND deleted_at IS NULL 
    if err := db.WithContext(ctx).Table("po").Where(datatypes.JSONQuery("extra").HasKey("key")).Find(&pos).Error; err != nil {
        t.Error(err)
        return
    }
```
### <font color="red">Where条件嵌套</font>
``` go
// WHERE (age = 1 AND name = 'xu') OR (age = 2 AND name  = 'x')   
db.Where(
    db.Where("age = 1").Where("name = ?","xu")
)
.Or(
    db.Where("age = 2").Where("name = ?","x")
)
```

### 数量统计 Count
- int64类型，传参时位引用
``` go
var cnt int64
// SELECT COUNT(*) FROM `po` WHERE age > 10
db.WithContext(ctx).Table("po").Where("age > ?", 10).Count(&cnt);
```
### 分组 Group和Scan, Find
- DB.Group 方法实现，<font color="red">分组之后的 Sum、Max、Avg 等聚合函数都可以通过 Select 方法进行声明</font>
``` go
    var groups []UserRecord
    // SELECT user_id, sum(amount) AS amount FROM `user_record` WHERE id < 100 AND deleted_at IS NULL GROUP BY user_id
    resDB := db.WithContext(ctx).Table("user_record")
    .Select("user_id", "sum(amount) AS amount").Where("id < ?", 100)
    .Group("user_id").Scan(&groups)
```

### 子查询 UpdateColumn("amount", subQuery)
- <font color="red">作为子查询的语句 只是未立即执行</font>
- UpdateColumn，字段=子查询

``` go
    // UPDATE `user_record` SET amount = (SELECT amount FROM `user_record` WHERE user_id = 1000 ORDER BY id DESC limit 1) WHERE user_id = 100 
    subQuery := db.Table("user_record").Select("amount").Where("user_id = ?", 1000) // 作为子查询的语句 只是未立即执行

    resDB := db.WithContext(ctx).Table("user_record").Where("user_id = ?", 100).UpdateColumn("amount", subQuery)
``` 

### 排序偏移
``` go
// ORDER BY age DESC LIMIT 2 OFFSET 10
Order("age DESC").Limit(2).Offset(10)
```
- <font color="red">踩坑：字符串 70 > 600 比较的是首字母，所以通过转成浮点型 又会出现null的情况，gorm无法处理</font>
![alt text](image7.png)

## 事务
- 自动开启事务 SkipDefaultTransaction 默认关闭 go.Config配置

- 调用 <font color="red">db.Transaction 方法</font>开启事务
- <font color="red">在 Transaction 中可以通过闭包函数执行事务逻辑</font>，其中所有事务操作都需要围绕着 tx *gorm.DB 实例展开
- 在闭包函数中，一旦返回 error 或者发生 panic，gorm 会自动执行回滚操作；<font color="red">倘若返回的 error 为 nil，gorm 会自动执行提交操作</font>
- 使用方也可以根据自己的需要，<font color="red">调用 tx.Rollback 和 tx.Commit 方法</font>提前执行回滚或提交操作
![alt text](image8.png)

### 事务里发生了异常会怎样
模拟 事务里手动 panic  
异常不处理就不继续执行  
异常处理了，失败的异常就事务回滚，然后继续执行其他

### 在事务中，针对某条记录可以通过 <font color="red">select for update </font>的方式进行加持写锁的操作
``` go
    // SELECT * FROM po WHERE id = 1 AND deleted_at IS NULL ORDER BY id ASC limit 1 FOR UPDATE    
    // 开启事务    
    db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {        
        // 针对一条 po 记录加写锁        
        var po PO        
        if err := tx.Set("gorm: query option", "FOR UPDATE").Where("id = ?", 1).First(&po).Error; err != nil {            
            return err        
        }               
         // 执行业务逻辑        
         return do(ctx, tx, &po)    // do上面的闭包函数
     })
```

### 事务里的<font color="red">find锁住问题</font>
- Clauses(clause.Locking{Strength: "UPDATE"})
- 事务 find为锁住, 手动加上update锁, 所有协程都会等
- **事务里的find 没加锁会导致并发取的都是 操作前的数据**
``` go
mysql.Main().Transaction  // 事务里的find 没加锁会导致并发取的都是 操作前的数据 
res := tx.Find(&acc, "id=?", id)
res := tx.Clauses(clause.Locking{Strength: "UPDATE"}).Find(&acc, "id=?", id)
```

## 回调
在定义 po 模型时，可以遵循 gorm 中预留的接口协议，声明指定的回调方法，这样能在特定操作执行前后执行用户预期的回调逻辑. <font color="red">一般自己业务层处理</font>
``` go
// 删除操作后回调
type AfterDeleteInterface interface {
    AfterDelete(*gorm.DB) error
}

// find 操作后回调
type AfterFindInterface interface {
    AfterFind(*gorm.DB) error
}
```