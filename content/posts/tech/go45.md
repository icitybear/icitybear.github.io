---
title: "Go配置读取-viper" #标题
date: 2024-03-06T14:01:03+08:00 #创建时间
lastmod: 2024-03-06T14:01:03+08:00 #更新时间
author: ["citybear"] #作者
categories: # 没有分类界面可以不填写
- tech
tags: # 标签
- go包
- go源码
keywords: 
- 
description: "" #描述 每个文章内容前面的展示描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true #是否展示评论 有自带的扩展成twikoo
showToc: true # 显示目录 文章侧边栏toc目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
    image: "" #图片路径：posts/tech/文章1/picture.png
    caption: "" #图片底部描述
    alt: ""
    relative: false

# reward: true # 打赏
mermaid: true #自己加的是否开启mermaid
---

# what

- github.com/spf13/viper 
  - github.com/fsnotify/fsnotify 提供跨平台文件系统通知 实现热更细
  - github.com/spf13/pflag  解析和管理命令行标志
  - github.com/mitchellh/mapstructure 进行结构体和map

- <font color="red">viper 是一个配置解决方案，拥有丰富的特性</font>
  1. 支持 JSON/TOML/YAML/HCL/envfile/Java properties 等多种格式的配置文件；
  2. <font color="red">可以设置监听配置文件的修改，修改时自动加载新的配置；</font>
  3. 从环境变量、命令行选项和io.Reader中读取配置；
  4. 从远程配置系统中读取和监听修改，如 etcd/Consul；
  5. 代码逻辑中显示设置键值。

# 配置文件
YAML 和 JSON 的替代方案。它的目标是比 JSON 更人性化，比 YAML 更简单。TOML 旨在明确映射到哈希表。TOML 应该易于解析为多种语言的数据结构。
<font color="red">[1分钟学习语法](https://www.cnblogs.com/xingxia/p/toml.html)</font>

# 使用
- config.toml
``` go
app_name = "awesome web"

# 注释
log_level = "DEBUG"

# 表
[mysql]
ip = "127.0.0.1"
port = 3306
user = "dj"
password = 123456
database = "awesome"

[redis]
ip = "127.0.0.1"
port = 7381

# 时间类型

# 点分割符
name = "橙子"
physical.color = "橙色"
physical.shape = "圆形"

// {
//   "name": "橙子",
//   "physical": {
//     "color": "橙色",
//     "shape": "圆形"
//   }
// }
```



- 设置文件名（SetConfigName）、配置类型（SetConfigType）和搜索路径（AddConfigPath），然后调用ReadInConfig。 viper会自动根据类型来读取配置。使用时调用viper.Get方法获取键值
- <font color="red">键名：使用section.key的形式，即传入嵌套的键名（表[]与点分割符.）</font>

``` go
func main() {
  viper.SetConfigName("config") // 设置文件名时不要带后缀；
  viper.SetConfigType("toml") // 文件类型是toml
  viper.AddConfigPath(".") // 搜索路径可以设置多个，viper 会根据设置顺序依次查找；
  viper.SetDefault("redis.port", 6381) // 默认值可以调用viper.SetDefault设  
  err := viper.ReadInConfig() // 使用此配置
  if err != nil {
    log.Fatal("read config failed: %v", err)
  }

  fmt.Println(viper.Get("app_name"))
  fmt.Println(viper.Get("log_level"))

  fmt.Println("mysql ip: ", viper.Get("mysql.ip")) //viper 获取值时使用section.key的形式，即传入嵌套的键名
}
```
# 读取
1. GetType系列方法可以返回指定类型的值。 其中，Type 可以为Bool/Float64/Int/String/Time/Duration/IntSlice/StringSlice。 但是请注意，如果指定的键不存在或类型不正确，GetType方法返回对应类型的零值。类型为配置的值确定
![alt text](image.png)
2. viper支持在多个地方设置，viper.Set, <font color="red">这个值的优先级最高</font>
3. <font color="red">读取顺序优先级：</font>调用Set显示设置的；命令行选项；环境变量；配置文件；默认值（SetDefault）

# 命令行 BindPFlags
- viper 使用 pflag 库来解析选项。调用viper.BindPFlags绑定选项到配置
``` go
func init() {
  pflag.Int("redis.port", 8381, "Redis port to connect")

  // 绑定命令行
  viper.BindPFlags(pflag.CommandLine)
}
```

# 环境变量 BindEnv
- viper.SetEnvPrefix方法设置环境变量前缀, 使用Get的时候，viper 会自动加上这个前缀再从环境变量中查找。
- BindEnv: 一个参数，则这个参数既表示键名，又表示环境变量名.两个参数，则第一个参数表示键名，第二个参数表示环境变量名
- 如果对应的环境变量不存在，viper 会自动将键名全部转为大写再查找一次

``` go
func init() {
  // 绑定所有环境变量
  // viper.AutomaticEnv()
  // 绑定环境变量
  viper.BindEnv("redis.port")
  viper.BindEnv("go.path", "GOPATH")
}

func main() {
  // 省略部分代码
  // fmt.Println("GOPATH: ", viper.Get("GOPATH")) // 使用viper.Get("gopath") 一样获取
  fmt.Println("go path: ", viper.Get("go.path"))
}
```

# 配置文件
- 为了避免环境变量的影响，需要删除xxx这个环境变量（根据是否以配置文件为准）

# 默认值 SetDefault

# 读取配置文件
- <font color="red">viper 支持从io.Reader中读取配置。这种形式很灵活，来源可以是文件，也可以是程序中生成的字符串，甚至可以从网络连接中读取的字节流。</font>
``` go
func main() {
  viper.SetConfigType("toml")
  tomlConfig := []byte(`
app_name = "awesome web"

# possible values: DEBUG, INFO, WARNING, ERROR, FATAL
log_level = "DEBUG"

[redis]
ip = "127.0.0.1"
port = 7381
`)
  err := viper.ReadConfig(bytes.NewBuffer(tomlConfig))
  if err != nil {
    log.Fatal("read config failed: %v", err)
  }

  fmt.Println("redis port: ", viper.GetInt("redis.port"))
}
```

- Unmarshal(rawVal any) : error 为结构体中的对应字段赋值。使用的反序列化是封装了mapstructure
- UnmarshalKey(key string, rawVal any) : error
``` go
type config struct {
	Port int
	Name string
	PathMap string `mapstructure:"path_map"`
}

var C config

err := viper.Unmarshal(&C)
if err != nil {
	t.Fatalf("unable to decode into struct, %v", err)
}
```

# 保存配置到文件 
将程序中生成的配置，或者所做的修改保存下来

- WriteConfig：将当前的 viper 配置写到预定义路径，如果没有预定义路径，返回错误。将会覆盖当前配置；
- WriteConfigAs：保存配置到指定路径，如果文件存在，则覆盖；
- SafeWriteConfig：与上面功能一样，但是如果配置文件存在，则不覆盖；

# <font color="red">监听文件修改</font>
- 监听文件修改，热加载配置。因此不需要重启服务器，就能让配置生效。
- viper.WatchConfig()
  
先打印redis.port的值，然后Sleep 10s。在这期间修改配置中redis.port的值，Sleep结束后再次打印。 发现打印出修改后的值
``` go
func main() {
  viper.SetConfigName("config")
  viper.SetConfigType("toml")
  viper.AddConfigPath(".")
  err := viper.ReadInConfig()
  if err != nil {
    log.Fatal("read config failed: %v", err)
  }

  viper.WatchConfig()

  fmt.Println("redis port before sleep: ", viper.Get("redis.port"))
  time.Sleep(time.Second * 10)
  fmt.Println("redis port after sleep: ", viper.Get("redis.port"))
}

// redis port before sleep:  7381
// redis port after sleep:  73810
``` 
- 为配置修改增加一个回调
``` go
viper.OnConfigChange(func(e fsnotify.Event) {
  fmt.Printf("Config file:%s Op:%s\n", e.Name, e.Op)
})
```

## WatchConfig源码解析
``` go
func (v *Viper) WatchConfig() {
	go func() {
    // fsnotify是用来监控目录及文件的第三方库；建立新的监视处理程序，NewWatcher里会go开启一个协程开始等待事件, 从I/O完成端口读取，将事件注入到Event对象中：Watcher.Events 通道进行协程通信
		watcher, err := fsnotify.NewWatcher()
		if err != nil {
			log.Fatal(err)
		}
		defer watcher.Close()
 
		filename, err := v.getConfigFile() // 配置文件完整路径
		if err != nil {
			log.Println("error:", err)
			return
		}
 
		configFile := filepath.Clean(filename)    //配置文件E:\etc\bizsvc\config.yml
		configDir, _ := filepath.Split(configFile)  // 配置文件所属目录 E:\etc\bizsvc\
 
		done := make(chan bool)
		go func() {
			for {
				select {
        // 读取的event对象有两个属性，Name为E:\etc\bizsvc\config.yml，Op为write（对文件的操作）
				case event := <-watcher.Events:
		      // 清除内部的..和他前面的元素，清除当前路径.，用来判断操作的文件是否是configFile
					if filepath.Clean(event.Name) == configFile {
            // 如果对该文件进行了创建操作或写操作
						if event.Op&fsnotify.Write == fsnotify.Write || event.Op&fsnotify.Create == fsnotify.Create {
							err := v.ReadInConfig() // tag: 执行v.ReadInConfig()后配置文件的内容将重新读取到viper实例中的config字段
							if err != nil {
								log.Println("error:", err)
							}
							v.onConfigChange(event) // tag: 通知变化 onConfigChange是核心结构体Viper的一个属性，类型是func
						}
					}
				case err := <-watcher.Errors:
          // 有错误将打印
					log.Println("error:", err)
				}
			}
		}()
 
		watcher.Add(configDir)
		<-done
	}()
}


```
## OnConfigChang
- OnConfigChange方法的参数会赋值给形参run并传到viper实例的onConfigChange属性，以WatchConfig()方法中的v.onConfigChange(event)来执行这个函数。
``` go
// 方法参数为一个函数，类型为func(in fsnotify.Event)) {}  自己的执行逻辑放到这个func里面，在监听到event时就会执行你写的函数
func (v *Viper) OnConfigChange(run func(in fsnotify.Event)) {
    v.onConfigChange = run
}
```

## 热更新的源码分析（基于fsnotify）
-  fsnotify是用来监控目录及文件的第三方库
``` go
viperInstance := viper.New()	// viper实例
viperInstance.WatchConfig()
viperInstance.OnConfigChange(func(e fsnotify.Event) {
	log.Print("Config file updated.")
	viperLoadConf(viperInstance)  // 加载配置的方法 要执行的逻辑
})
```