---
title: "php设计模式" #标题
date: 2023-07-06T14:57:11+08:00 #创建时间
lastmod: 2023-07-06T14:57:11+08:00 #更新时间
author: ["citybear"] #作者
categories: # 没有分类界面可以不填写
- tech
tags: # 标签
- 设计模式
keywords: 
- 
description: "" #描述 每个文章内容前面的展示描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true #是否展示评论 有自带的扩展成twikoo
showToc: true # 显示目录 文章侧边栏toc目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
    image: "" #图片路径：posts/tech/文章1/picture.png
    caption: "" #图片底部描述
    alt: ""
    relative: false

# reward: true # 打赏
mermaid: true #自己加的是否开启mermaid
---

# 慕课网视频教程
- [慕课网教程](http://www.imooc.com/learn/236)
# php代码例子
- [代码例子](https://laravelacademy.org/books/php-design-pattern)
# 设计6大原则
- [设计6大原则](https://www.cnblogs.com/lina520/p/7993478.html)

**设计模式的目的是为了更好的代码重用性，可读性，可靠性和可维护性。常用的六大设计模式有：单一职责原则（SRP），里氏替换原则（LSP），依赖倒转原则（DIP），接口隔离原则（ISP），迪米特法则（LOD），开闭原则（OCP）。**

<font color="red">高内聚低耦合。</font>

1. SRP 一个类应该只负责一项职责

2. LSP 其实可以简单地理解为所有引用基类的地方必须能够透明的使用其子类的对象，在子类中尽量不要重写和重载父类的方法。
比如：因为C类虽然继承了A类，但是它重写了A类的subtract方法，造成了原有功能的错误。*在实际的编码过程中我们通常会重写父类的方法来完成新的功能，但是这样会使得类的继承体系复用性特别差*
A和C共同继承一个更通俗的基类，然后实现他的方法，去掉A和C的继承关系，<font color="red">采用依赖、聚合、组合等关系代替</font>

  - LSP指出：子类类型必须能够替换掉它们的父类型、并出现在父类能够出现的任何地方。（参数逆变，扩展）。。返回值类型斜变（缩小）
父类的方法可在子类中实现或者重写。使用声明时，<font color="red">只应该使用父类对象</font>而不应当直接使用子类对象，这样可以实现运行期绑定（动态多态）

3. DIP 高层不应该依赖低层二者都应该依赖其抽象；<font color="red">抽象不应该依赖于细节</font>，细节应该依赖于抽象
 - 应该依赖于接口的依赖倒置原则
 - 依赖关系的传递有三种办法，分别是<font color="red">接口传递、构造方法传递以及setter方法传递。</font> 
 - 依赖注入模式 <font color="red">控制反转(IOC)</font>的一种实现

4. ISP 一个类不应该依赖他不需要的接口；一个类对另一个类的依赖应该建立在最小接口上。接口隔离原则
 - 单一职责原则是注重的这个类的职责，而接口隔离原则注重对接口依赖的隔离
 - 单一职责约束的是类，其次是方法，针对的是程序中的实现和细节，而接口隔离原则约束的是接口，是抽象，是程序框架整体的构建。

5. LOD 迪米特原则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。

6. OCP 模块和函数应该对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节

- 23种设计模式的目的就是遵循开闭原则。简单的理解就是构建框架的时候要保持足够的扩展性，通扩展来实现修改代码而不是直接修改代码。

# 单例模式
- 某个类得对象仅允许创建一次、 数据库操作对象 避免大量的 new 操作，因为每一次 new 操作都会消耗系统和内存的资源。
- 只能被其自身实例化。它不会创建实例副本，而是会向单例类内部存储的实例返回一个引用。确保一个类只能创建一个对象，这么做可以极大节省内存空间
- 可以结合工厂模式
- <font color="red">3私1公</font>
``` php
<?php
public static function getInstance($pconnect = false){
    if(FALSE == (self::$_instance instanceof self)){
        self::$_instance = new self($pconnect);
    }
    return self::$_instance;
}
```
- PHP单例模式我觉得只是针对单次页面级请求时出现多个应用场景并<font color="red">需要共享同一对象资源</font>时是非常有意义的。(PHP语言是一种解释型的脚本语言，这种运行机制使得每个PHP页面被解释执行后，所有的相关资源都会被回收)
  
# 工厂模式
- 方便统一更改 资源对象参数等  
- 使用工厂类创建对象，而不是直接使用 new。至少有一个公共的静态方法（称为“工厂方法”），静态方法接受一个参数，根据这个参数来创建不同类的对象。比如一些数据库资源 redis资源等
  
# 原型模式
- 大对象的创建 内存拷贝 （ 对象实例 = clone 对象实例） 
- <font color="red">需要一个对象在某个状态下的副本，</font> 这个前提很重要（**需要对比一个对象经过处理后的状态和处理前的状态是否发生过改变**，可能我们就需要在执行某段处理之前，克隆这个对象此时状态的副本，然后等执行后的状态进行相应的对比）
![](yuanxing.png)

# 注册模式
- 全局共享和交换对象 对象注册到全局注册树上  参数的传递 很多地方用到的时候考虑注册模式  
- 使用的对象<font color="red">创建一个中央存储器来存放这些对象</font>
- **只包含静态方法的抽象类来实现（或者通过单例模式<font color="red">单例数组</font>**

# 依赖注入模式  

{{< innerlink src="posts/tech/design.md" >}}

# 策略模式
- 将一组特定的行为和算法封装成类，以适应某些特定的上下文环境 
- （if else  如电商针对男女跳到不同商品类目 显示不同的广告） 使用给策略接口约定行为  上下文参数 选取设定相应策略 然后进行调用  
- 从硬编码到解耦（2个类互相依赖 A中使用B b类不需要定义 再执行的时候再绑定好对应类策略//依赖倒置）  针对分支模式

# 数据对象映射模式
将对象和数据存储映射起来, 操作对象时就映射为对数据存储操作  <font color="red">orm类封装数据</font> 复杂的就结合 工厂模式 注册器模式）

# 迭代器模式

- 遍历中 也能修改内部元素的值
- 提供一种方法访问一个容器（Container）对象中各个元素，而又不需暴露该对象的内部细节。 
- PHP标准库（SPL）中提供了迭代器接口 Iterator，<font color="red">要实现迭代器模式，实现该接口即可 implements \Iterato </font>
![](diedaiqi.png)

# 观察者模式
- 只有两个角色 —— 观察者 + 被观察者 类似发布/订阅模式
- 事件（继承于事件生产者 抽象基类）发生后,触发对应的消息,需要处理逻辑（内部 去通知事件发生前添加的观察者：接口类）,通知到位 对应的观察者有对应的事件行为

**比如 用户登录 后续操作**
主体（被观察的对象） =》通过魔术方法（监听发生改变），或者前置方法=》<font color="red">通知（被添加的观察者）调用遍历观察者</font> =》触发的观察者的方法
![](guanchazhe.png)

# 适配器模式
- 将截然不同的函数接口封装成统一API  比如msql mysqli pdo3种  比如memcache redis file等 ,<font color="red">具体类继承接口并实现其方法</font> 不同环境可能有不同数据库 框架根据环境去适配
- <font color="red">适配器模式为它所适配的对象提供了一个不同的接口。</font> 适配器模式将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作
  
**比如纸质书接口, 电子书适配器 通过构造注入电子书接口类型 转换为电子书对应方法**
1. EBookInterface 接口的方法pressNext  pressStart 与PaperBookInterface接口的方法open turnPage不一致，
2. <font color="red">通过适配器 EBookAdapter继承了PaperBookInterface接口</font>，
3. **依赖注入**了EBookInterface $ebook 将PaperBookInterface接口的open turnPage 
4. 转为了EBookInterface来实现open==><font color="red">$this->eBook->pressStart();</font>

### 与代理模式区别
适配器模式为它所适配的对象提供了一个不同的接口，而代理提供了与它的实体相同的接口。

# 装饰器模式
![](decorator.png)
- 尽量使用对象组合，而不是对象继承来扩展和复用功能。装饰器模式就是基于对象组合的方式 （还有trait）
- **<font color="red">装饰器必须实现 interface 接口，否则的话就不是装饰器而只是个包裹类。</font>**
- 场景：
  - 需要在不影响其他对象的情况下，以动态、透明的方式给对象添加职责。
  - 如果不适合使用子类来进行扩展的时候，可以考虑使用装饰器模式。
动态地添加修改类功能 同一个方法不同的实现效果 子类继承重写如果比较多样的话比较麻烦，这时候使用装饰者模式，<font color="red">装饰器接口 方法前中后修改 ,类在调用方法时候，进行装饰器方法的调用（装饰器数组），事先可以动态添加所需要的装饰器，注意点 装饰器调用的时候 after记得反转 before顺序 after后进先出</font>

**例子：Web服务层 —— 为 REST 服务提供 JSON 和 XML 装饰器。**
通过实现接口,比如为web层提供 数据的处理功能，不同装饰器类提供不一样的处理

**比如：以前的游拍商城(装饰器模式和策略模式)**

# 代理模式
使用代理模式创建代理对象，让代理对象控制目标对象的访问（目标对象可以是远程的对象、创建开销大的对象或需要安全控制的对象），并且可以在不改变目标对象的情况下添加一些额外的功能。
- 代理模式在很多情况下都非常有用，特别是你想**<font color="red">强行控制一个对象的时候，比如延迟加载、监视状态变更的方法等等。</font>**
- 
**tq企业的xy框架**
**比如：读写分离**

## 与相似模式的区别：
- 适配器模式-适配器模式为它所适配的对象提供了一个不同的接口，而<font color="red">代理提供了与它的实体相同的接口。</font>
- 装饰器模式-两者目的不同：<font color="red">装饰器为对象添加一个或多个功能，而代理则控制对对象的访问</font>

# 门面模式
又称外观模式，用于为子系统中的一组接口提供一个一致的界面。门面模式定义了一个高层接口，这个接口使得子系统更加容易使用：引入外观角色之后，用户只需要直接与外观角色交互，<font color="red">用户（Client）与子系统之间的复杂关系由门面角色来实现，从而降低了系统的耦合度。</font>

- 外观角色（Facade）：提供一个外观接口，对外，它提供一个易于客户端访问的接口，对内，它可以访问子系统中的所有功能。
- 子系统角色（SubSystem）：子系统在整个系统中可以是一个或多个模块，每个模块都有若干类组成，这些类可能相互之间有着比较复杂的关系。
- 客户端（Client）：外观接口调用测试者
- 让子系统内部的模块更易维护和扩展
  
**例子，我们家里有很多家居，比如空调、热水器、窗帘、扫地机器人，假设这些家居都是由不同的对象来进行控制的，就会有空调控制对象、热水器控#制对象、窗帘控制对象、扫地机器人控制对象。然而，这些我们都可以不需要，我们只需要一个小爱同学音箱，就可以把这些控制都集中再一个控制器上，我们需要开空调，只需要对小爱同学说开空调就可以了。所以之前的其他遥控器我们都可以不用关心了，我们只需要关注小爱同学就够了。这个时候我们就可以使用外观模式。**

**Laravel 中门面模式的使用也很广泛，基本上每个服务容器中注册的服务提供者类都对应一个门面类**
