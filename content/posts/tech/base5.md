---
title: "数据的易容术：编码、哈希与加密技术" #标题
date: 2023-10-26T15:05:09+08:00 #创建时间
lastmod: 2023-10-26T15:05:09+08:00 #更新时间
author: ["citybear"] #作者
categories: # 没有分类界面可以不填写
- tech
tags: # 标签
- 基础
- 网络
keywords: 
- 
description: "" #描述 每个文章内容前面的展示描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true #是否展示评论 有自带的扩展成twikoo
showToc: true # 显示目录 文章侧边栏toc目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
    image: "" #图片路径：posts/tech/文章1/picture.png
    caption: "" #图片底部描述
    alt: ""
    relative: false

# reward: true # 打赏
mermaid: true #自己加的是否开启mermaid
---
# 数据编码：
- 定义：主要目的是为了高效、可靠地处理和数据传输，而非隐藏信息内容，确保数 据在不同系统间能够可靠传输。
- 特性：确定性：相同的输入必须产生相同的输出。可逆： 
- 常见的应用场景： 
   1. 例如解决二进制数据在仅支持文本的协议中传输的问题。
   2. 在URL、Cookie中嵌入简单数据 
   3. 短链接 
- 常用的算法：base64 URL编码 进制转换
# hash函数
- 定义：是一种将<font color="red">任意长度的数据映射为固定长度的哈希值的函数。</font>它能够将输入数 据转换为一串数字或字母组成的固定长度字符串
- 特性
  - • 确定性：相同的输入必须产生相同的输出。这意味着如果输入数据不变，哈希函数的输出也必须一致。 
  - • 高效性：计算哈希值的速度应较快，以确保在实际应用中能够迅速完成大量的哈希运算。 
  - • 均匀性：好的哈希函数能够使输入数据在哈希值空间中分布均匀，以减少冲突。这意味着对于关键字集合 中的任意一个关键字，经过哈希函数映射到地址集合中任何一个地址的概率是相等的。 
  - • 抗冲突性：不同的输入《特别是相似的输入）产生相同输出的概率应尽可能低。理想情況下，哈希函数应 该尽量避免将不同的输入映射到相同的哈希值（即碰撞率）。 
  - • 安全性：在特定的应用场景下，如密码存储，哈希函数需要是单向的，即不能从哈希值反推出原始数据。<font color="red">（不可逆）</font>

- 常见的应用场景
1. 数据完整性验证 通过对比数据的哈希值，可以确保数据在传输过程中未被篡改。
2. 脱敏: 直接存储用户的明文密码存在极大的安全风险。通过加盐后再进行hash处理
3. 数字签名 第三和第四次握手给的摘要
4. 去重与查找： 在处理大量数据时，需要快速判断数据是否已经存在(布隆过滤器)，或者查找具有相同特征的数据SimHash。
5. 负载均衡： 
   1. 场景：在分布式系统中，通过哈希算法将请求均匀分配到不同的服务器，实现负载均衡。 
   2. 描述：由于哈希算法均有均匀性，可以对请求参数或用户id进行哈希后，根据哈希值分配对应的后端服务 
      - ip哈希（用户id哈希） 
      - url哈希 
      - 一致性哈希 {{< innerlink src="posts/tech/redis3.md" >}}  
6. 数据分片(hash分桶)
   1. 场景：在处理大规模数据时，通过哈希算法将数据分片，可以提高处理效率和可扩展性。 
   2. 描述：大数据在数据存储的时候，根据某个字段的哈希取模后，把相同哈希值的数据存入同一分片，
      - 由于哈希均匀性，使得每个分片之间的数据量相对比较平均，不容易出现数据倾斜的情况
      - 在做数据join的时候，不同表的同分片可以进行小范围的join，从而减少join的传输io和计算量
   - 案例
   我们实现了基于uuid的游标拉取方式，但是拉取下一页的需要等待上一页的结果，不符合推送的多线程拉取，需要进异步对游标拉取的模式进行分段式（分桶）支持。
   1.  支持传递分段数、当前进行编号进行分段式的游标分页拉取；
   2. 改造查询支持分段式拉取数据
``` sql
   // BIGINT 8个字节的整数。Long 类型，取值范围是[-9223372036854775808，9223372036854775807]。
   SELECT MOD((hg_sip_hash_64(user_id)&9223372036854775807), 6) AS bucket, user_id, instance_id,create_time
   FROM tq_user_portrait.user_group_crowd_hour_2025100120 
   where instance_id=94279 and MOD((hg_sip_hash_64(user_id)&9223372036854775807), 6) = 0 and user_id > 'Cfbq7pgeecv2'
   order by user_id asc
   Limit xxxx offset xxx;
```

- 常用的hash算法 
  - MD5
  - SHA 
  - Murmur（性能好，随机分布特征表现更良好，低碰撞率） 分为32位64位
  - Cityhash （性能好，随机分布特征表现更良好，低碰撞率） 
  - SipHash （性能好，安全性） 
  - SM3 （国产）
  - SimHash (相似度)

# 加密算法
- 定义：是一种数据处理方法，它将普通文本（明文）转换成无法直接阅读的密文，只有通过特定的解密过程才能恢 复原始信息。

1. 加密和解密
   - 将一段大家看得懂的信息（明文）转换为另一段大家看不懂的信息（密文），其实就是加密。
   - 发送方利用接收方的公钥对要发送的明文进行加密,接受方利用自己的私钥进行解密,其中公钥和私钥匙相对的,任何一个作为公钥,则另一个 就为私钥.<font color="red">**但是因为非对称加密技术的速度比较慢,所以,一般采用对称加密技术加密明文,然后用非对称加密技术加密对称密钥,即数字信封技术.**</font>

2. 签名和验证
   - 发送方用特殊的hash算法，由明文中产生固定长度的摘要，然后<font color="red">**利用自己的私钥对形成的摘要进行加密，这个过程就叫签名。接受方利用 发送方的公钥解密被加密的摘要得到结果A，然后对明文也进行hash操作产生摘要B.最后,把A和B作比较。**</font>此方式既可以保证发送方的身份不可抵赖，又可以保证数据在传输过程中不会被篡改。

# 加密分类
- 摘要算法：严格意义上摘要算法不算是加密算法，是哈希算法(国产:SM3 国际: MD5. SHA-1, MAC, SHA-2 (SHA-224, SHA-256, SHA-384, SHA-512, SHA- 512/224, SHA-512/256)) 
  - 应用场景： 完整性验证 脱敏 数字签名

1. 单向散列加密：经过对数据进行摘要计算生成密文，<font color="red">密文不可逆推还原。结果字符串长度固定</font>, 比如MD5 (32,16)，SHA1 (40,20)，CRYPT(24,13);
2. 双向加密：与单向加密相反，能够把密文逆推还原成明文，双向加密又分为对称加密和非对称加密。 比如 url, base64
   1. 对称加密：指数据使用者必须拥有**相同的密钥**才能够进行加密解密，就像彼此约定的一串暗号<font color="red">(可逆向  密钥同一个)</font>。算法表明：DES，3DES，AES(更高级的DES)，IDEA，RC4，RC5;
     - 内部通信：在安全的内部网络中，如企业内网的数据传输。 
     - 大量数据加密：视频流、大数据文件传输等需要高速处理的场景。 
     - 数据库加密：存储在数据库中的敏感信息，如用户密码的加密存储。
  
   2. 非对称加密：非对称加密须要公开密钥和私有密钥两组密钥，**公开密钥和私有密钥是配对起来的**，也就是说使用公开密钥进行数据加密，只有对应的私有密钥才能解密。**这两个密钥是数学相关,公钥负责加密，私钥负责解密。公钥人人可得，私钥永远不泄**，算法表明：<font color="red">RSA</font>，DSA 国产:SM2. SM9 国际:RSA, Rabin, DH, DSA, ECC
     - 密钥交换：在对称加密前，使用非对称加密来安全地交换对称密钥。 
     - 数字信封
     - 身份验证：例如SSL/TLS协议中，服务器向客户端证明自己的身份。 
     - 加密电子邮件：PGP和S/MIME协议利用非对称加密来保护邮件内容的隐私。
- [【有道云笔记】常见加密 ](https://note.youdao.com/s/ECnnRMTX)

# 案例1（对称加密）
传纸条：课间十分钟里告诉我，"每个字母向左移动一位，就是我想对你说的话"。然后在上课的时候，递出纸条，上面写了 eb tib cj。每个帮助传递纸条的同学看了之后，都暗骂“谜语人，你给我滚出哥谭镇”。嘿嘿，你们不懂，我懂。我拿到纸条后，将每个字母向左移动一位，得到 da sha bi。

# 案例2（非对称加密）
- <font color="red">为什么用公钥加密却不能用公钥解密？</font>

``` go
// 比如求余运算。
5^2 mod 7 = 25 mod 7 = x // 很容易得到x=4。
// 我们换一下x的位置。
5^x mod 7 = 4
// 求x等于多少的时候
5^0 mod 7 = 1
5^1 mod 7 = 5
5^2 mod 7 = 4 // x=2
5^3 mod 7 = 6
5^4 mod 7 = 2
// 但如果上面的模数字变得巨大无比 正常CPU要跑好多年才能算出来，所以可以认为算不出来。
5^x mod 56374677648 = 4
```
上面的公式就是将 5 加密成了4。如果已知x，就很容易算出等式右边的结果是4，而反过来，从4却难以反推得到出x的值是多少。因此说这样的取模算法是不可逆的。
**结合欧拉定理，却可以让这个公式在一定条件下变得有点“可逆”（注意是加了引号的）**
``` json
// 原文^(p*q) mod N = 原文
// 如果p, q, N选取得当，原文一波取模操作之后还是变回原文。
//... 直接上结论 知道 p就能加密，知道 q就能解密。
// 原文^(p) mod N = 密文
// 密文^(q) mod N = 原文
```
数学原理决定了我们用公钥加密的数据，只有私钥能解密。反过来，用私钥加密的数据，也只有公钥能解密。从数学原理也能看出，公钥和私钥加密是安全的，但这件事情的前提是建立在"现在的计算机计算速度还不够快"这个基础上。因此，如果有一天科技变得更发达了，我们变成了更高维度的科技文明，可能现在的密文就跟明文没啥区别了。

# 数字信封技术例子
- MD5 比 SHA1 大约快 33% 
- DES：本地数据，安全级别低 (AES代替DES, DES的派生算法3DES)
在2001年，DES作为一个标准已经被高级加密标准（AES）所取代。另外，DES已经不再作为国家标准科技协会（前国家标准局）的一个标准。
- AES：更快，兼容设备，安全级别高
- SM3替换MD5 SM2优于RSA
- RSA是公钥加密,速度慢,只能处理少量数据,优点是公钥即使在不安全的网络上公开,也能保证安全。<font color="red">常见情况是双方用RSA协商出一个密钥后,通过AES/3AES给明文数据加密。也就是数字信封技术</font>

![alt text](image.png)
1. 第一次握手：

• Client Hello：是客户端告诉服务端，它支持什么样的加密协议版本，比如 TLS1.2，使用什么样的加密套件，比如最常见的RSA，同时还给出<font color="red">一个客户端随机数。</font>

2. 第二次握手：

• Server Hello：服务端告诉客户端，<font color="red">服务器随机数 + 服务器证书（本质上是，被权威数字证书机构（CA）的私钥加密过的服务器公钥）</font> + 确定的加密协议版本（比如就是TLS1.2）。

3. 第三次握手：

• Client Key Exchange: 此时客户端再生成一个随机数，叫 pre_master_key 。<font color="red">从第二次握手的服务器证书里取出服务器公钥，用公钥加密 pre_master_key，发给服务器。</font>

• Change Cipher Spec: 客户端这边已经拥有三个随机数：客户端随机数，服务器随机数和pre_master_key，<font color="red">用这三个随机数进行计算得到一个"会话秘钥"。此时客户端通知服务端，后面会用这个会话秘钥进行对称机密通信。</font>

• Encrypted Handshake Message：客户端会把迄今为止的通信数据内容生成一个摘要，用"会话秘钥"加密一下，发给服务器做校验，此时客户端这边的握手流程就结束了，因此也叫Finished报文。

4. 第四次握手：

• Change Cipher Spec：<font color="red">服务端此时拿到客户端传来的 pre_master_key</font>（虽然被服务器公钥加密过，但服务器有私钥，能解密获得原文），集齐三个随机数，跟客户端一样，用这三个随机数通过同样的算法获得一个"会话秘钥"。此时服务器告诉客户端，后面会用这个"会话秘钥"进行加密通信。

• Encrypted Handshake Message：跟客户端的操作一样，将迄今为止的通信数据内容生成一个摘要，用"会话秘钥"加密一下，发给客户端做校验，到这里，服务端的握手流程也结束了，因此这也叫Finished报文

- <font color="red">前期4次握手，本质上就是在利用非对称加密的特点，交换三个随机数。目的就是为了最后用这三个随机数生成对称加密的会话秘钥。后期就一直用对称机密的方式进行通信。</font>


- 服务器证书，本质上是，被权威数字证书机构（CA）的私钥加密过的服务器公钥。第二次握手的时候，客户端可以通过CA的公钥，来解密服务器证书，从而拿到藏在里面的服务器公钥
- 全世界要上网的人那么多，都用去请求CA官网的话，官网肯定顶不住。CA公钥也不多，把他们直接作为配置放到操作系统或者浏览器里

- HTTPS相当于HTTP+TLS，目前主流的是TLS1.2，基于TCP三次握手之后，再来TLS四次握手。
- TLS四次握手的过程中涉及到两对私钥和公钥。<font color="red">分别是服务器本身的私钥和公钥，以及CA的私钥和公钥</font>

## 问题
1. 为什么我不能只传公钥，而要拿CA的私钥加密一次再传过去？

只传公钥，公钥就有可能会在传输的过程中就被黑客替换掉。然后第三次握手时客户端会拿着假公钥来加密第三个随机数 pre_master_key，黑客解密后自然就知道了最为关键的 pre_master_key。第一次和第二次握手里的客户端随机数和服务端随机数，都是明文的，因此就可以计算出"会话秘钥"。

2. 为什么要用三个随机数？而不是一个或两个？

因为只有单个 pre_master_key随机性不足，多次随机的情况下有可能出来的秘钥是一样的。但如果再引入两个随机数，就能大大增加"会话秘钥"的随机程度，从而保证每次HTTPS通信用的会话秘钥都是不同的。

3. 为什么第三和第四次握手还要给个摘要？
   - 摘要，说白了就是对一大段文本进行一次hash操作。目的是为了确认通信过程中数据没被篡改过。
   - 为什么要hash一次而不是直接拿原文进行对比？因为原文内容过长，hash之后可以让数据变短。更短意味着更小的传输成本。
**第三次握手，客户端生成摘要，服务端验证，如果验证通过，说明客户端生成的数据没被篡改过，服务端后面才能放心跟客户端通信。第四次握手，则是反过来，由服务端生成摘要，客户端来验证，验证通过了，说明服务端是可信任的。**

# <font color="red">PHP实现RSA，DES,AES算法</font>
- [PHP通用的 OPENSSL 方式实现RSA算法，DES算法](https://note.youdao.com/s/LUi62bpr)
- [PHP 实现AES,DES算法 CBC ECB模式](https://note.youdao.com/s/B6S1CErY)
  
# SM国产商密算法
https://git.internal.taqu.cn/go/g3


# 国密算法与国际标准算法的对比
![alt text](image1.png)

- 常见国密算法与国际标准算法各参数性能的对比如下：
![alt text](image2.png)

![alt text](image3.png)

# 数据脱敏
数据脱敏是一种对敏感信息进行变形处理的技术机制，目的是在保留数据原有特征和业务属性的同时， 防止敏感数据在非生产环境或未授权访问中泄露
- 泛化类方法 
  - •截断方法：砍掉数据的一部分，比如手机号只留前三位。 
  - •取整方法：对数字或时间进行简化，比如工资四舍五入到十元。 
  - •归类方法：把数据分分类，比如工资分成高、中、低三个级别。 
  
- 扰乱类方法 
  - •加密方法：把数据变成别人看不懂的样子。 
  - •散列方法：把数据变成固定长度的结果，不能逆转。 
  - •混淆方法：打乱数据的顺序，比如把12345变成53241。
  
-  抑制方法
   - 用*或？代替敏感数据，比如手机号后八位变成星号

-  仿真方法
   - 创建看起来很像真实数据，但实际上完全不同的新数据集。

【有道云笔记】反爬 抓取快手 评论数值 是韩文 具体数据抓取思路有以下几种（爬虫）
https://share.note.youdao.com/s/2kJM1Aip

【有道云笔记】字体反爬（爬虫）
https://share.note.youdao.com/s/3m8Dg2z3