---
title: "加密解密，签名和验签" #标题
date: 2023-10-26T15:05:09+08:00 #创建时间
lastmod: 2023-10-26T15:05:09+08:00 #更新时间
author: ["citybear"] #作者
categories: # 没有分类界面可以不填写
- tech
tags: # 标签
- 基础
- 网络
keywords: 
- 
description: "" #描述 每个文章内容前面的展示描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true #是否展示评论 有自带的扩展成twikoo
showToc: true # 显示目录 文章侧边栏toc目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
    image: "" #图片路径：posts/tech/文章1/picture.png
    caption: "" #图片底部描述
    alt: ""
    relative: false

# reward: true # 打赏
mermaid: true #自己加的是否开启mermaid
---
# 概念
1. 加密和解密
   - 将一段大家看得懂的信息（明文）转换为另一段大家看不懂的信息（密文），其实就是加密。
   - 发送方利用接收方的公钥对要发送的明文进行加密,接受方利用自己的私钥进行解密,其中公钥和私钥匙相对的,任何一个作为公钥,则另一个 就为私钥.<font color="red">**但是因为非对称加密技术的速度比较慢,所以,一般采用对称加密技术加密明文,然后用非对称加密技术加密对称密钥,即数字信封技术.**</font>

2. 签名和验证
   - 发送方用特殊的hash算法，由明文中产生固定长度的摘要，然后<font color="red">**利用自己的私钥对形成的摘要进行加密，这个过程就叫签名。接受方利用 发送方的公钥解密被加密的摘要得到结果A，然后对明文也进行hash操作产生摘要B.最后,把A和B作比较。**</font>此方式既可以保证发送方的身份不可抵赖，又可以保证数据在传输过程中不会被篡改。

# 加密分类
1. 单向散列加密：经过对数据进行摘要计算生成密文，<font color="red">密文不可逆推还原。结果字符串长度固定</font>, 比如MD5 (32,16)，SHA1 (40,20)，CRYPT(24,13);
2. 双向加密：与单向加密相反，能够把密文逆推还原成明文，双向加密又分为对称加密和非对称加密。 比如 url, base64
   1. 对称加密：指数据使用者必须拥有**相同的密钥**才能够进行加密解密，就像彼此约定的一串暗号<font color="red">(可逆向  密钥同一个)</font>。算法表明：DES，3DES，AES(更高级的DES)，IDEA，RC4，RC5;
   2. 非对称加密：非对称加密须要公开密钥和私有密钥两组密钥，**公开密钥和私有密钥是配对起来的**，也就是说使用公开密钥进行数据加密，只有对应的私有密钥才能解密。**这两个密钥是数学相关,公钥负责加密，私钥负责解密。公钥人人可得，私钥永远不泄**，算法表明：<font color="red">RSA</font>，DSA。
- [【有道云笔记】常见加密 ](https://note.youdao.com/s/ECnnRMTX)

# 案例1（对称加密）
传纸条：课间十分钟里告诉我，"每个字母向左移动一位，就是我想对你说的话"。然后在上课的时候，递出纸条，上面写了 eb tib cj。每个帮助传递纸条的同学看了之后，都暗骂“谜语人，你给我滚出哥谭镇”。嘿嘿，你们不懂，我懂。我拿到纸条后，将每个字母向左移动一位，得到 da sha bi。

# 案例2（非对称加密）
- 为什么用公钥加密却不能用公钥解密？

``` go
// 比如求余运算。
5^2 mod 7 = 25 mod 7 = x // 很容易得到x=4。
// 我们换一下x的位置。
5^x mod 7 = 4
// 求x等于多少的时候
5^0 mod 7 = 1
5^1 mod 7 = 5
5^2 mod 7 = 4 // x=2
5^3 mod 7 = 6
5^4 mod 7 = 2
// 但如果上面的模数字变得巨大无比 正常CPU要跑好多年才能算出来，所以可以认为算不出来。
5^x mod 56374677648 = 4
```
上面的公式就是将 5 加密成了4。如果已知x，就很容易算出等式右边的结果是4，而反过来，从4却难以反推得到出x的值是多少。因此说这样的取模算法是不可逆的。
**结合欧拉定理，却可以让这个公式在一定条件下变得有点“可逆”（注意是加了引号的）**
``` json
// 原文^(p*q) mod N = 原文
// 如果p, q, N选取得当，原文一波取模操作之后还是变回原文。
//... 直接上结论 知道 p就能加密，知道 q就能解密。
// 原文^(p) mod N = 密文
// 密文^(q) mod N = 原文
```
数学原理决定了我们用公钥加密的数据，只有私钥能解密。反过来，用私钥加密的数据，也只有公钥能解密。从数学原理也能看出，公钥和私钥加密是安全的，但这件事情的前提是建立在"现在的计算机计算速度还不够快"这个基础上。因此，如果有一天科技变得更发达了，我们变成了更高维度的科技文明，可能现在的密文就跟明文没啥区别了。

# 数字信封技术例子
- MD5 比 SHA1 大约快 33% 
- DES：本地数据，安全级别低 (AES代替DES, DES的派生算法3DES)
在2001年，DES作为一个标准已经被高级加密标准（AES）所取代。另外，DES已经不再作为国家标准科技协会（前国家标准局）的一个标准。
- AES：更快，兼容设备，安全级别高
- SM3替换MD5 SM2优于RSA
- RSA是公钥加密,速度慢,只能处理少量数据,优点是公钥即使在不安全的网络上公开,也能保证安全。<font color="red">常见情况是双方用RSA协商出一个密钥后,通过AES/3AES给明文数据加密。也就是数字信封技术</font>

![alt text](image.png)
1. 第一次握手：

• Client Hello：是客户端告诉服务端，它支持什么样的加密协议版本，比如 TLS1.2，使用什么样的加密套件，比如最常见的RSA，同时还给出一个客户端随机数。

2. 第二次握手：

• Server Hello：服务端告诉客户端，服务器随机数 + 服务器证书 + 确定的加密协议版本（比如就是TLS1.2）。

3. 第三次握手：

• Client Key Exchange: 此时客户端再生成一个随机数，叫 pre_master_key 。从第二次握手的服务器证书里取出服务器公钥，用公钥加密 pre_master_key，发给服务器。

• Change Cipher Spec: 客户端这边已经拥有三个随机数：客户端随机数，服务器随机数和pre_master_key，用这三个随机数进行计算得到一个"会话秘钥"。此时客户端通知服务端，后面会用这个会话秘钥进行对称机密通信。

• Encrypted Handshake Message：客户端会把迄今为止的通信数据内容生成一个摘要，用"会话秘钥"加密一下，发给服务器做校验，此时客户端这边的握手流程就结束了，因此也叫Finished报文。

4. 第四次握手：

• Change Cipher Spec：服务端此时拿到客户端传来的 pre_master_key（虽然被服务器公钥加密过，但服务器有私钥，能解密获得原文），集齐三个随机数，跟客户端一样，用这三个随机数通过同样的算法获得一个"会话秘钥"。此时服务器告诉客户端，后面会用这个"会话秘钥"进行加密通信。

• Encrypted Handshake Message：跟客户端的操作一样，将迄今为止的通信数据内容生成一个摘要，用"会话秘钥"加密一下，发给客户端做校验，到这里，服务端的握手流程也结束了，因此这也叫Finished报文
前期4次握手，本质上就是在利用非对称加密的特点，交换三个随机数。目的就是为了最后用这三个随机数生成对称加密的会话秘钥。后期就一直用对称机密的方式进行通信。


- 服务器证书，本质上是，被权威数字证书机构（CA）的私钥加密过的服务器公钥。第二次握手的时候，客户端可以通过CA的公钥，来解密服务器证书，从而拿到藏在里面的服务器公钥
- 全世界要上网的人那么多，都用去请求CA官网的话，官网肯定顶不住。CA公钥也不多，把他们直接作为配置放到操作系统或者浏览器里

- HTTPS相当于HTTP+TLS，目前主流的是TLS1.2，基于TCP三次握手之后，再来TLS四次握手。
- TLS四次握手的过程中涉及到两对私钥和公钥。分别是服务器本身的私钥和公钥，以及CA的私钥和公钥

## 问题
1. 为什么我不能只传公钥，而要拿CA的私钥加密一次再传过去？

只传公钥，公钥就有可能会在传输的过程中就被黑客替换掉。然后第三次握手时客户端会拿着假公钥来加密第三个随机数 pre_master_key，黑客解密后自然就知道了最为关键的 pre_master_key。第一次和第二次握手里的客户端随机数和服务端随机数，都是明文的，因此就可以计算出"会话秘钥"。
2. 为什么要用三个随机数？而不是一个或两个？

因为只有单个 pre_master_key随机性不足，多次随机的情况下有可能出来的秘钥是一样的。但如果再引入两个随机数，就能大大增加"会话秘钥"的随机程度，从而保证每次HTTPS通信用的会话秘钥都是不同的。

3. 为什么第三和第四次握手还要给个摘要？
   - 摘要，说白了就是对一大段文本进行一次hash操作。目的是为了确认通信过程中数据没被篡改过。
   - 为什么要hash一次而不是直接拿原文进行对比？因为原文内容过长，hash之后可以让数据变短。更短意味着更小的传输成本。
第三次握手，客户端生成摘要，服务端验证，如果验证通过，说明客户端生成的数据没被篡改过，服务端后面才能放心跟客户端通信。第四次握手，则是反过来，由服务端生成摘要，客户端来验证，验证通过了，说明服务端是可信任的。


# <font color="red">PHP实现RSA，DES,AES算法</font>
- [PHP通用的 OPENSSL 方式实现RSA算法，DES算法](https://note.youdao.com/s/LUi62bpr)
- [PHP 实现AES,DES算法 CBC ECB模式](https://note.youdao.com/s/B6S1CErY)
  
# SM国产商密算法
https://git.internal.taqu.cn/go/g3


# 国密算法与国际标准算法的对比
![alt text](image1.png)

- 常见国密算法与国际标准算法各参数性能的对比如下：
![alt text](image2.png)

![alt text](image3.png)