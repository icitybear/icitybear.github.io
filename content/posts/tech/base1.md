---
title: "原码、反码和补码" #标题
date: 2023-07-12T23:25:40+08:00 #创建时间
lastmod: 2023-07-12T23:25:40+08:00 #更新时间
author: ["citybear"] #作者
categories: # 没有分类界面可以不填写
- tech
tags: # 标签
- 基础
keywords: 
- 
description: "" #描述 每个文章内容前面的展示描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true #是否展示评论 有自带的扩展成twikoo
showToc: true # 显示目录 文章侧边栏toc目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
    image: "" #图片路径：posts/tech/文章1/picture.png
    caption: "" #图片底部描述
    alt: ""
    relative: false

# reward: true # 打赏
mermaid: true #自己加的是否开启mermaid
---

# 原码、反码和补码
计算机底层是通过二进制表示数字的，我们把这种<font color="red">二进制形式的数字称之为机器数</font>，数字是有正负之分的，这个正负是通过机器数的第一位作为标识的（俗称符号位）：<font color="red">0 表示正数，1 表示负数。<font>为区别有符号数真实值与形式值的不同，又将带符号位的机器数对应的真正数值称为机器数的<font color="red">真值</font>（无符号数的真值就是自身）。

除了基本的二进制数字外，计算机还提供了<font color="red">三种数字编码方式：原码、反码和补码。</font>

## 原码就是符号位+真值，比如：

[+1]原 = 0000 0001
[-1]原 = 1000 0001

以 8 位二进制数表示范围为例，使用原码的话对应的区间范围是 [11111111, 01111111]，即 [-127, 127]。

## 反码
我们接着来看反码，<font color="red">正数的反码是自身，负数的反码是在其原码基础上，符号位不变，其余各位按位取反。</font>比如：

[+1]反 = 0000 0001
[-1]反 = 1111 1110

以 8 位二进制数表示范围为例，使用反码的话对应的区间范围是 [11111111, 01111111]，还是 [-127, 127]。

上面两种编码都存在一个问题，那就是<font color="red">数字 0 存在 +0 和 -0 两种编码：</font>

[+0]原 = 0000 0000
[-0]原 = 1000 0000

[+0]反 = 0000 0000
[-0]反 = 1111 1111 // 补码+1

这就导致数字 0 在计算机中的编码不唯一，对于凡事要求确定性的计算机来说，这是绝对不行的，<font color="red">为了解决这个问题，计算机科学家们又提出补码的概念。</font>

## 补码
正数的补码和反码一样，都是其自身，而负数的补码是在其原码基础上，<font color="red">符号位不变</font>，其余各位按位取反，<font color="red">最后+1（即反码+1）</font>。比如：
[+1]补 = 0000 0001
[-1]补 = 1111 1111

就是这个简单的 +1，却非常巧妙地解决了数字 0 双重编码的问题，现在，**+0 的补码是 0000 0000**，但是 <font color="red">-0 的补码变成了 0000 0000</font>，所以只有一个表示 0 的编码了。

不仅如此，所有的负数都整体做了 +1 操作，<font color="red">之前的 1111 1111 由于**进位溢出**，变成了 1000 0000（补码），我们将这个数字用于表示 -128，</font>所以对于 8 位机器数，通过补码表示的话，现在的情况是：

  - 正数区间依然是 [0, 127] 不变；
  - 负数区间变成了 [-128, -1]（之前 [-127, -0] 每个数字 +1 演化而来）。

这也是目前计算机系统底层 8 位整型数字的区间范围，所以<font color="red">计算机底层是通过补码来表示数字的，也只能通过补码来表示。</font>

## uint 类型的 255 转化为 int8 类型的值后是 -1
了解到这里，我们再来看为什么 **uint 类型**的 255 转化为 int8 类型的值后是 -1。

255 是无符号正数，补码和原码都是 255，即 16 个 1 组成的机器数，转化为 int8 类型后，由于 int8 只能存放 8 位机器数，所以<font color="red">会截取 255 后 8 位数字，也就是 1111 1111</font>，int8 是有符号数字，第一位是符号位，所以真值是后 7 位，计算机底层通过补码表示数字，<font color="red">需要将其转化为补码</font>，而这个数字又是负数，所以需要将后 7 位按位取反再 +1，也就是 1000 0001，即 -1