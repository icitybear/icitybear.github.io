---
title: "Go单元测试" #标题
date: 2025-09-12T16:19:11+08:00 #创建时间
lastmod: 2025-09-12T16:19:11+08:00 #更新时间
author: ["citybear"] #作者
categories: # 没有分类界面可以不填写
- tech
tags: # 标签
- go基础
- 工具
keywords: 
- 
description: "" #描述 每个文章内容前面的展示描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true #是否展示评论 有自带的扩展成twikoo
showToc: true # 显示目录 文章侧边栏toc目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
    image: "" #图片路径：posts/tech/文章1/picture.png
    caption: "" #图片底部描述
    alt: ""
    relative: false

# reward: true # 打赏
mermaid: true #自己加的是否开启mermaid
---

# 单元测试概述

- <font color="red">基础测试，性能测试，事例测试，模糊测试以及分析代码覆盖率</font>
- 必须以 "x_test.go" 格式命名,测试函数也必须以一定格式命名
- 包testing定义了与单元测试有关的函数或者结构
- go test 命令编译相关Go文件，并运行对应的测试函数，最终输出测试结果，包括测试结果，包名，运行时间等，而如果执行失败，还会输出详细错误信息。

``` go
// 基础测试 通常用来判断结果是否符合预期，如果不符合可使用t.Errorf输出原因，也标示着此次测试结果失败
func TestXxx(t *testing.T) { ... }

// 性能测试  将运行指定代码b.N次，输出结果包含运行次数以及平均每次耗时
func BenchmarkXxx(b *testing.B) { ... }

// 模糊测试的本质是依靠随机函数生成随机测试用例来进行测试验证
func FuzzXxx(f *testing.F) { ... }

// 事例测试 必须包含注释并指定输出Output，通过对比输出结果，判定测试结果是否通过 
func ExampleXxx() {
    Println("The output of\nthis example.")
    // Output: The output of
    // this example.
}
```

# 执行目录 超时时间等指令

``` go
// 因为vscode直接打开的code 直接使用ide工具运行测试
// tag: /usr/local/go/bin/go test -timeout 30s -run ^TestKy$ code/ch_uuid
// 会提示 package code/ch_uuid is not in GOROOT (/usr/local/go/src/code/ch_uuid)

//		package记得按目录命名 
//	 /usr/local/go/bin/go test -timeout 30s -run ^TestKy$ 才准确uuid 进入该目录
```

``` 

-args 必须放在所有 go test 参数之后
     go test -v -args -config=testdata/config.json
`-config=testdata/config.json` 会作为参数传递给测试代码的 `os.Args`

-c
     go test -c -o mytest ./mypkg  # 生成 mytest 二进制文件
     ./mytest -test.v              # 手动运行测试
仅生成可执行的测试二进制文件（如 mypkg.test），后续可手动运行。适用于需要单独调试测试或交叉编译的场景。

-timeout 
超时时间设置
```

# <font color="red">基础测试</font>
一般配合断言语法进行基础测试
``` go
func TestAppendOverlap(t *testing.T) {
    x := []byte("1234")
    x = append(x[1:], x...) // p > q in runtime·appendslice.
    got := string(x)
    want := "2341234" // 想要的结果
    if got != want {
        t.Errorf("overlap failed: got %q want %q", got, want)
    }
}

//ok      demo    0.503s

//  如果执行结果不符合预期
--- FAIL: TestAppendOverlap (0.00s)
    demo_test.go:13: overlap failed: got "xxx" want "xxx"
```

# <font color="red">性能测试</font>

对一段代码，通过执行多次，计算平均耗时，以此评估程序性能；执行总时间或者执行次数可通过参数指定

- go test -性能参数 -bench 文件路径
- 性能测试执行时间；注意Nx可设置代码段执行循环次数 -benchtime t     -benchtime 10000x
- 性能测试执行次数 -count n
- 设置逻辑处理器数目，默认为CPU核数 -cpu 1,2,4
- 指定文件方法 -bench 指定方法

## 例子1
``` go
// Go语言字符串是只读的，不能修改的，字符串相加也是通过申请内存与数据拷贝方式实现，如果存在大量的字符串相加逻辑，每次都申请内存拷贝数据效率会非常差；而stringBuilder底层维护了一个[]byte，追加字符串只是追加到该切片，最终一次性转换该切片为字符串，避免了中间N多次的内存申请与数据拷贝，所以性能较好。

func BenchmarkStringPlus(b *testing.B) {
    s := ""
    for i := 0; i < b.N; i++ {
        s += "abc"
    }
}

func BenchmarkStringBuilder(b *testing.B) {
    build := strings.Builder{}
    for i := 0; i < b.N; i++ {
        build.WriteString("abc")
    }
}

// 执行命令
go test -benchtime 100000x  -count 3 -bench .
//BenchmarkStringPlus-8 表示逻辑处理器P数目为8
BenchmarkStringPlus-8            100000         15756 ns/op
BenchmarkStringPlus-8            100000         14203 ns/op
BenchmarkStringPlus-8            100000         15751 ns/op
BenchmarkStringBuilder-8         100000             4.148 ns/op
BenchmarkStringBuilder-8         100000             3.663 ns/op
BenchmarkStringBuilder-8         100000             3.372 ns/op
PASS
ok      demo    4.686s

```

## 例子2 并发
- RunParallel

性能测试需要并行执行，可以通过RunParallel实现，其会创建多个协程执行你的代码，协程数目默认与逻辑处理器P数目保持一致，这种方式的性能测试通常需要结合-cpu参数一起使用

``` go
func BenchmarkMutex(b *testing.B) {
    var lock sync.Mutex
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            lock.Lock()
            foo := 0
            for i := 0; i < 100; i++ {
                foo *= 2
                foo /= 2
            }
            _ = foo
            lock.Unlock()
        }
    })
}

go test -benchtime 100000x -cpu 1,2,4,8 -bench .
BenchmarkMutex           100000            46.62 ns/op
BenchmarkMutex-2         100000            50.70 ns/op
BenchmarkMutex-4         100000            64.98 ns/op
BenchmarkMutex-8         100000           113.3 ns/op
PASS
ok      demo    0.139s
```

## 事例测试

通过在注释并指定输出Output（如果没有不执行事例测试），通过对比输出结果，判定测试结果是否通过
- Output是顺序有关的
- 使用Unordered output 可以无序
``` go
func ExampleSum256() {
    sum := sha256.Sum256([]byte("hello world\n"))
    fmt.Printf("%x", sum)
    // Output: a948904f2f0f479b8f8197694b30184b0d2ed1c1cd2a1ec0fb85d299a192a447
}

func ExampleUnorder() {
    for _, value := range []int{1,2,3,4,0} {
        fmt.Println(value)
    }
    // Unordered output: 4
    // 2
    // 1
    // 3
    // 0
}

```

# 模糊测试

模糊测试（Fuzzing）是一种通过向目标系统提供非预期的输入并监视异常结果来发现软件漏洞的方法

为什么需要模糊测试呢？因为理论上你不可能穷举所有输入作为测试用例，**模糊测试的本质是依靠随机函数生成随机测试用例来进行测试验证，是不确定的**

- go test -性能参数 -fuzz=指定方法
- 模糊测试执行时间；Nx表示执行多少次 -fuzztime t  -benchtime 10000x
- 指定文件方法 -fuzz=指定方法

``` go
func FuzzHex(f *testing.F) {
    //添加种子参数
    for _, seed := range [][]byte{{}, {0}, {9}, {0xa}, {0xf}, {1, 2, 3, 4}} {
        f.Add(seed)
    }
    f.Fuzz(func(t *testing.T, in []byte) {
        enc := hex.EncodeToString(in)
        out, err := hex.DecodeString(enc)
        if err != nil {
            t.Fatalf("%v: decode: %v", in, err)
        }
        if !bytes.Equal(in, out) {
            t.Fatalf("%v: not equal after round trip: %v", in, out)
        }

    })
}

go test  -fuzztime 10000x -fuzz=FuzzHex
fuzz: elapsed: 0s, gathering baseline coverage: 0/24 completed
fuzz: elapsed: 0s, gathering baseline coverage: 24/24 completed, now fuzzing with 8 workers
fuzz: elapsed: 0s, execs: 10000 (117451/sec), new interesting: 0 (total: 24)
PASS
ok      demo    0.339s
```

# <font color="red">代码覆盖率</font>

- 命令go test -cover 输出覆盖率
``` go
// 定义了商品结构，包含商品类型以及商品名称，有一个函数可根据商品分类返回商品名称
type Product struct {
    Type int
    Name string
}

func ProductName(t int) string{
    switch t {
    case 1:
        return "手机"
    case 2:
        return "电脑"
    case 3:
        return "显示器"
    case 4:
        return "键盘"
    default:
        return "不知道"
    }
}

var tests = []Product{
    {1, "手机"}, // 只测了一种情况
}

func TestType(t *testing.T) {
    for _, p := range tests {
        name := ProductName(p.Type)
        if name != p.Name {
            t.Errorf("ProductName(%d) = %s; want %s ", p.Type, name, p.Name)
        }
    }
}

go test -cover
PASS
coverage: 33.3% of statements   //只覆盖了33.3%的语句
ok      demo    3.049s
```