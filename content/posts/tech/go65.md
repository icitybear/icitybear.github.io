---
title: "Go包-semaphore包信号量Weighted" #标题
date: 2025-08-19T20:38:26+08:00 #创建时间
lastmod: 2025-08-19T20:38:26+08:00 #更新时间
author: ["citybear"] #作者
categories: # 没有分类界面可以不填写
- tech
tags: # 标签
- go包
- go并发编程
keywords: 
- 
description: "" #描述 每个文章内容前面的展示描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true #是否展示评论 有自带的扩展成twikoo
showToc: true # 显示目录 文章侧边栏toc目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
    image: "" #图片路径：posts/tech/文章1/picture.png
    caption: "" #图片底部描述
    alt: ""
    relative: false

# reward: true # 打赏
mermaid: true #自己加的是否开启mermaid
---

# 概念
- 信号量（Semaphore）是一种计数器<font color="red">用于控制多个线程对共享资源的访问。(最大并发数)</font>当一个线程访问共享资源时它会尝试获取信号量，如果号量的值大于 0，则该线程可以访问共享资源并将信号量的值减 1；如果信号量的值等于 0，则该线程必须等待其他线程释放信号量后才能访问共享资源。
- 信号量（Semaphore）是一种同步原语，用于实现多线程和多进程之间的同步和互斥。信号量的本质是一个整数计数器，通常用于限制对共享资源的访问数量。信号量的实现涉及到两个关键操作：wait（或称为P操作）和post（或称为V操作）。
  - 初始化：信号量在创建时需要进行初始化，通常将计数器设置为允许同时访问共享资源的最大数量。
  - Wait（P）操作：当一个线程或进程想要访问共享资源时，会执行wait操作。在wait操作中，信号量的计数器减1。如果计数器的值为负数，表示没有可用的资源，执行wait操作的线程/进程将被阻塞，直到有资源可用。
  - Post（V）操作：当一个线程或进程完成对共享资源的访问后，会执行post操作。在post操作中，信号量的计数器加1。如果计数器的值小于等于0，表示有等待的线程/进程，此时会唤醒一个被阻塞的线程/进程

# 作用
- golang.org/x/sync/semaphore 官方扩展包
- 控制最大并发数(最大协程数)
```go
// tag: 锁结构体
type Mutex struct {
	state int32  // 第1-3位，4-32
	sema  uint32 // 信号量 用于阻塞和唤醒 goroutine 的信号量 就是指semaphore 
	// tag: Golang 协程之间的抢锁，实际上争抢给Locked赋值的权利，能给 Locked 置为1，就说明抢锁成功。抢不到就阻塞等待 sema 信号量，一旦持有锁的协程解锁，那么等待的协程会依次被唤醒。
}
```
- Golang 对信号量的实现却是隐藏在 runtime 中，并没有包含到标准库里
```go
func runtime_Semacquire(s *uint32) // 阻塞等待直到 s 大于 0，然后立刻将 s 减去 1【原子操作】；
func runtime_Semrelease(s *uint32, handoff bool, skipframes int) // 将 s 增加 1，然后通知一个阻塞在 runtime_Semacquire 的 goroutine【原子操作】
// 原子操作，一个 acquire，一个 release，其实就代表了对资源的获取和释放
```
- <font color="red">Mutex 作为 sync 包的核心，支撑了 RWMutex，channel，singleflight 等多个并发控制的能力</font>
 - 对信号量的管理又是 Mutex 的基础, 虽然源码看不到，但 Golang 其实在扩展库 golang.org/x/sync/semaphore 也提供了一套信号量的实现


# channel缓存通道 模拟信号量
- 可以模拟出来 n 个信号量的效果，但就<font color="red">不具备 semaphore Weighted 这套实现里面，一次获取多个资源的能力了。</font>
```go
type Semaphore chan struct{}

func NewSemaphore(n int) Semaphore {
    return make(Semaphore, n)
}

func (s Semaphore) Wait() {
    s <- struct{}{}
}

func (s Semaphore) Signal() {
    <-s
}
```

``` go
func main() {
	// 创建一个容量为3的通道
	ch := make(chan struct{}, 3)

	// 依次执行10个任务，每次执行前发送一个信号到通道
	for i := 0; i < 10; i++ {
		ch <- struct{}{} // 申请资源  tag: 放协程里和放协程外区别 在于协程是否要先起
		go func(i int) {
			defer func() {
				<-ch // 释放资源
			}()
			fmt.Println("Task", i, "begin")
			time.Sleep(time.Second) // 模拟一个耗时操作
			fmt.Println("Task", i, "end")
		}(i)
	}

	// 等待所有任务完成
	time.Sleep(10 * time.Second)
}

// 申请资源：ch <- struct{}{} 在协程外部执行，这意味着在启动协程之前，主线程会先将一个信号发送到通道中。这确保了只有当通道中有可用的槽位时，才会启动新的协程。
// 释放资源：<-ch 在协程内部的defer语句中执行，确保在协程结束时释放资源。
// 并发控制：这种方式可以有效地控制同时运行的协程数量，因为每次启动协程前都会检查通道的容量。如果通道已满，主线程会阻塞，直到有资源可用。
```

## 通道的例子里 ch <- struct{}{} 放协程外和协程里的区别
``` go
func main() {
	// 创建一个容量为3的通道
	ch := make(chan struct{}, 3)

	// 依次执行10个任务，每次执行前发送一个信号到通道
	for i := 0; i < 10; i++ {
		go func(i int) {
			ch <- struct{}{} // 申请资源
			defer func() {
				<-ch // 释放资源
			}()
			fmt.Println("Task", i, "begin")
			time.Sleep(time.Second) // 模拟一个耗时操作
			fmt.Println("Task", i, "end")
		}(i)
	}

	// 等待所有任务完成
	time.Sleep(10 * time.Second)
}
```
## 区别
- 申请资源再启动协程:因为每次启动协程前都会检查通道的容量。如果通道已满，主线程会阻塞，直到有资源可用。
- 启动协程再申请资源:协程的启动不会被阻塞。<font color="red">所有协程都会立即启动，然后在尝试发送信号时阻塞。这可能导致更多的上下文切换和资源竞争。</font>
  
# semaphore包 信号量
``` go
func main() {
	// 创建一个最大容量为3的信号量
	sp := semaphore.NewWeighted(3)

	// 依次执行10个任务，每次执行前申请1个资源
	for i := 0; i < 10; i++ {
		// 申请资源
		sp.Acquire(context.Background(), 1)
		go func(i int) {
			defer func() {
				// 释放资源
				sp.Release(1)
			}()
			fmt.Println("Task", i, "begin")
			time.Sleep(time.Second) // 模拟一个耗时操作
			fmt.Println("Task", i, "end")
		}(i)
	}

	// 等待所有任务完成
	time.Sleep(10 * time.Second)
}
```

# 总结
- semaphore包：
  - <font color="red">支持加权信号量，可以更灵活地控制资源的申请和释放。</font>
  - <font color="red">提供了Acquire方法的超时机制，可以通过context来控制超时。</font>
  - 内部实现较为复杂，<font color="red">可能在高并发场景下性能略逊于通道。</font>
- 通道（channel）：
  - 仅支持**固定容量**的资源控制，不支持加权。
  - 没有内置的超时机制，但可以<font color="red">通过select语句和time.After来实现超时。</font>
  

# 源码分析
- 当前剩余的资源 = size(总资源数) - cur（当前已被使用的资源）
- 使用sync.Mutex进行资源的增减时的保护
- 使用context控制该goroutine,建立一个属于这个 goroutine 的 waiter 要申请的资源n和协程间的通道,塞到等待队列

``` go
package semaphore // import "golang.org/x/sync/semaphore"

import (
	"container/list"
	"context"
	"sync"
)

type waiter struct {
	n     int64
	ready chan<- struct{} // ready 结构是个空结构体的 channel，仅仅是为了实现协程间通信
}

func NewWeighted(n int64) *Weighted {
	w := &Weighted{size: n}
	return w
}

type Weighted struct {
    size    int64       // 最大资源数
    cur     int64       // 当前已被使用的资源
    mu      sync.Mutex // 单机锁实现资源保护
    waiters list.List   // 等待队列 队列结构体
}

func (s *Weighted) Acquire(ctx context.Context, n int64) error {
	done := ctx.Done() // 上下文ctx的chan

	s.mu.Lock()
	select {
	case <-done:
		// 上下文控制能力 对此ctx进行 cancel, 可以设置 timeout 等待超时，就能对 acquire 行为进行更多约束
		s.mu.Unlock()
		return ctx.Err()
	default:
	}
	// tag: 代表剩余的资源是足够，同时 waiters 这个等待队列为空，代表没有别的协程在等待
	if s.size-s.cur >= n && s.waiters.Len() == 0 {
		// 直接 cur 加上 n 即可，代表又消耗了 n 个资源 然后解锁返回
		s.cur += n 
		s.mu.Unlock()
		return nil
	}

	// tag: 请求的资源数量，甚至都大于资源总数量了
	if n > s.size {
		s.mu.Unlock() // 先解个锁，别耽误别的 goroutine 拿资源
		<-done // 等你的 context 什么时候 Done，给你返回 context 的错误
		return ctx.Err()
	}

	// 剩余后面的情况
	// tag: 资源是够的，只是现在没有，那就把当前goroutine加到排队的队伍里
	ready := make(chan struct{})
	w := waiter{n: n, ready: ready} // tag:建立一个属于这个 goroutine 的 waiter 要申请的资源n和协程间的通道
	elem := s.waiters.PushBack(w) // tag: waiter塞到等待队列 waiters 里(Weighted成员  waiters list.List)
	s.mu.Unlock() // 直接解锁，因为你已经来排队了，手续处理完成，以后的路有别的通知机制保证，就没必要在这儿拿着锁阻塞新来的 goroutine 了，它也得排队

	// 阻塞起来，进行多路监听
	select {
	case <-done: // 该goroutine 的上下文超时了 2种情况
		s.mu.Lock() // 涉及资源增减也要加锁

		select {
		case <-ready: // 此时ready收到通知了 说明该goroutine拿到资源了
			s.cur -= n
			s.notifyWaiters() // 调用 notifyWaiters，叫现在排队第一的goroutine来领东西了
		default: // 未拿到资源
			isFront := s.waiters.Front() == elem // 判断goroutine 同时也是排在最前的 goroutine
			s.waiters.Remove(elem) // tag: 超时了，此时还没拿到资源，首先会把当前 goroutine 从 waiters 等待队列里移除（合情合理，你既然因为自己的原因做不了主，没法继续等待了，就别耽误别人事了）。
	
			// tag: 这个 goroutine 同时也是排在最前的 goroutine，而且恰好现在有资源了
			if isFront && s.size > s.cur {
				s.notifyWaiters() // 调用 notifyWaiters，叫排队第一的goroutine来领东西了
			}
		}

		s.mu.Unlock() // 解锁
		return ctx.Err() // 返回上下文超时err
	
	case <-ready: // 正常收到通知了 说明该goroutine拿到资源了

		select {
		case <-done:
			s.Release(n) // 此时超时了 直接释放资源
			return ctx.Err()
		default:
		}
		return nil
	}
}

// TryAcquire 就是Acquire 方法的 fast path，只是返回了个 bool，标识是否获取成功。
func (s *Weighted) TryAcquire(n int64) bool {
	s.mu.Lock()
	// tag: 代表剩余的资源是足够，同时 waiters 这个等待队列为空，代表没有别的协程在等待
	success := s.size-s.cur >= n && s.waiters.Len() == 0
	if success {
		s.cur += n
	}
	s.mu.Unlock()
	return success
}

// Release 释放资源
func (s *Weighted) Release(n int64) {
	s.mu.Lock()
	// 将 cur 减去 n 即可，说明此时又有 n 个资源可用了 回到总资源池
	s.cur -= n
	if s.cur < 0 {
		s.mu.Unlock()
		panic("semaphore: released more than held")
	}
	s.notifyWaiters() // 调用 notifyWaiters，叫排队第一的goroutine来领资源
	s.mu.Unlock()
}
// notifyWaiters 通知排队第一的goroutine来领资源
func (s *Weighted) notifyWaiters() {
	for {
		next := s.waiters.Front() // 排队最前的 waiter
		if next == nil {
			break
		}

		w := next.Value.(waiter)
		// 判断资源不够的情况
		if s.size-s.cur < w.n {
			break // 要的多不是错，既然你排第一，目前货不多，那就大家一起阻塞等待，保障你的权利
			// 先看看你后面那个 goroutine 人家够不够，虽然你现在是排位第一个，但是也得继续等着；(优先满足后面的，在一些情况下会饿死有大资源要求的 goroutine，设计上不希望这样的情况发生。)
			// 排第一，需求我就得满足，所以我们都继续等，等啥时候资源够了就给你
		}

		// 资源够的情况
		s.cur += w.n // 增加 cur 变量，资源给你，然后把你从等待队列里移出去
		s.waiters.Remove(next)
		close(w.ready) //  close通道 通知对应的goroutine就行 
	}
}

```

