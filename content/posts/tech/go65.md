---
title: "Go包-semaphore信号量" #标题
date: 2025-08-19T20:38:26+08:00 #创建时间
lastmod: 2025-08-19T20:38:26+08:00 #更新时间
author: ["citybear"] #作者
categories: # 没有分类界面可以不填写
- tech
tags: # 标签
- go包
- go并发编程
keywords: 
- 
description: "" #描述 每个文章内容前面的展示描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true #是否展示评论 有自带的扩展成twikoo
showToc: true # 显示目录 文章侧边栏toc目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
    image: "" #图片路径：posts/tech/文章1/picture.png
    caption: "" #图片底部描述
    alt: ""
    relative: false

# reward: true # 打赏
mermaid: true #自己加的是否开启mermaid
---

# 概念
- 信号量（Semaphore）是一种计数器<font color="red">用于控制多个线程对共享资源的访问。(最大并发数)</font>当一个线程访问共享资源时它会尝试获取信号量，如果号量的值大于 0，则该线程可以访问共享资源并将信号量的值减 1；如果信号量的值等于 0，则该线程必须等待其他线程释放信号量后才能访问共享资源。
- 信号量（Semaphore）是一种同步原语，用于实现多线程和多进程之间的同步和互斥。信号量的本质是一个整数计数器，通常用于限制对共享资源的访问数量。信号量的实现涉及到两个关键操作：wait（或称为P操作）和post（或称为V操作）。
  - 初始化：信号量在创建时需要进行初始化，通常将计数器设置为允许同时访问共享资源的最大数量。
  - Wait（P）操作：当一个线程或进程想要访问共享资源时，会执行wait操作。在wait操作中，信号量的计数器减1。如果计数器的值为负数，表示没有可用的资源，执行wait操作的线程/进程将被阻塞，直到有资源可用。
  - Post（V）操作：当一个线程或进程完成对共享资源的访问后，会执行post操作。在post操作中，信号量的计数器加1。如果计数器的值小于等于0，表示有等待的线程/进程，此时会唤醒一个被阻塞的线程/进程

# 作用
- golang.org/x/sync/semaphore 官方扩展包
- 控制最大并发数(最大协程数)
```go
// tag: 锁结构体
type Mutex struct {
	state int32  // 第1-3位，4-32
	sema  uint32 // 信号量 用于阻塞和唤醒 goroutine 的信号量 就是指semaphore 
	// tag: Golang 协程之间的抢锁，实际上争抢给Locked赋值的权利，能给 Locked 置为1，就说明抢锁成功。抢不到就阻塞等待 sema 信号量，一旦持有锁的协程解锁，那么等待的协程会依次被唤醒。
}
```
- Golang 对信号量的实现却是隐藏在 runtime 中，并没有包含到标准库里
```go
func runtime_Semacquire(s *uint32) // 阻塞等待直到 s 大于 0，然后立刻将 s 减去 1【原子操作】；
func runtime_Semrelease(s *uint32, handoff bool, skipframes int) // 将 s 增加 1，然后通知一个阻塞在 runtime_Semacquire 的 goroutine【原子操作】
// 原子操作，一个 acquire，一个 release，其实就代表了对资源的获取和释放
```
- <font color="red">Mutex 作为 sync 包的核心，支撑了 RWMutex，channel，singleflight 等多个并发控制的能力</font>
 - 对信号量的管理又是 Mutex 的基础, 虽然源码看不到，但 Golang 其实在扩展库 golang.org/x/sync/semaphore 也提供了一套信号量的实现


# channel缓存通道 模拟信号量
- 可以模拟出来 n 个信号量的效果，但就<font color="red">不具备 semaphore Weighted 这套实现里面，一次获取多个资源的能力了。</font>
```go
type Semaphore chan struct{}

func NewSemaphore(n int) Semaphore {
    return make(Semaphore, n)
}

func (s Semaphore) Wait() {
    s <- struct{}{}
}

func (s Semaphore) Signal() {
    <-s
}
```

``` go
func main() {
	// 创建一个容量为3的通道
	ch := make(chan struct{}, 3)

	// 依次执行10个任务，每次执行前发送一个信号到通道
	for i := 0; i < 10; i++ {
		ch <- struct{}{} // 申请资源  tag: 放协程里和放协程外区别 在于协程是否要先起
		go func(i int) {
			defer func() {
				<-ch // 释放资源
			}()
			fmt.Println("Task", i, "begin")
			time.Sleep(time.Second) // 模拟一个耗时操作
			fmt.Println("Task", i, "end")
		}(i)
	}

	// 等待所有任务完成
	time.Sleep(10 * time.Second)
}

// 申请资源：ch <- struct{}{} 在协程外部执行，这意味着在启动协程之前，主线程会先将一个信号发送到通道中。这确保了只有当通道中有可用的槽位时，才会启动新的协程。
// 释放资源：<-ch 在协程内部的defer语句中执行，确保在协程结束时释放资源。
// 并发控制：这种方式可以有效地控制同时运行的协程数量，因为每次启动协程前都会检查通道的容量。如果通道已满，主线程会阻塞，直到有资源可用。
```

## 通道的例子里 ch <- struct{}{} 放协程外和协程里的区别
``` go
func main() {
	// 创建一个容量为3的通道
	ch := make(chan struct{}, 3)

	// 依次执行10个任务，每次执行前发送一个信号到通道
	for i := 0; i < 10; i++ {
		go func(i int) {
			ch <- struct{}{} // 申请资源
			defer func() {
				<-ch // 释放资源
			}()
			fmt.Println("Task", i, "begin")
			time.Sleep(time.Second) // 模拟一个耗时操作
			fmt.Println("Task", i, "end")
		}(i)
	}

	// 等待所有任务完成
	time.Sleep(10 * time.Second)
}
```
## 区别
- 申请资源再启动协程:因为每次启动协程前都会检查通道的容量。如果通道已满，主线程会阻塞，直到有资源可用。
- 启动协程再申请资源:协程的启动不会被阻塞。<font color="red">所有协程都会立即启动，然后在尝试发送信号时阻塞。这可能导致更多的上下文切换和资源竞争。</font>
  
# semaphore包 信号量
``` go
func main() {
	// 创建一个最大容量为3的信号量
	sp := semaphore.NewWeighted(3)

	// 依次执行10个任务，每次执行前申请1个资源
	for i := 0; i < 10; i++ {
		// 申请资源
		sp.Acquire(context.Background(), 1)
		go func(i int) {
			defer func() {
				// 释放资源
				sp.Release(1)
			}()
			fmt.Println("Task", i, "begin")
			time.Sleep(time.Second) // 模拟一个耗时操作
			fmt.Println("Task", i, "end")
		}(i)
	}

	// 等待所有任务完成
	time.Sleep(10 * time.Second)
}
```

# 总结
- semaphore包：
  - <font color="red">支持加权信号量，可以更灵活地控制资源的申请和释放。</font>
  - <font color="red">提供了Acquire方法的超时机制，可以通过context来控制超时。</font>
  - 内部实现较为复杂，<font color="red">可能在高并发场景下性能略逊于通道。</font>
- 通道（channel）：
  - 仅支持固定容量的资源控制，不支持加权。
  - 没有内置的超时机制，但可以<font color="red">通过select语句和time.After来实现超时。</font>

# 源码分析
- https://www.jb51.net/article/257650.htm