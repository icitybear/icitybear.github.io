---
title: "网关下go服务502问题总结" #标题
date: 2025-08-25T18:20:47+08:00 #创建时间
lastmod: 2025-08-25T18:20:47+08:00 #更新时间
author: ["citybear"] #作者
categories: # 没有分类界面可以不填写
- tech
tags: # 标签
- 网络编程
keywords: 
- 
description: "" #描述 每个文章内容前面的展示描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true #是否展示评论 有自带的扩展成twikoo
showToc: true # 显示目录 文章侧边栏toc目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
    image: "" #图片路径：posts/tech/文章1/picture.png
    caption: "" #图片底部描述
    alt: ""
    relative: false

# reward: true # 打赏
mermaid: true #自己加的是否开启mermaid
---

服务端开发最常见的问题可能就是HTTP状态码异常了，常见的异常状态码包括404 Not Found，502 Bad Gateway，504 Gateway Time-out等。其中502状态码最常见并且最复杂

1. 为什么Go服务超时返回的是502状态码？
2. 明明我们设置的请求超时时间为3s，为什么实际的请求处理耗时却是5.049s？

- 502状态码的含义是Bad Gateway，看上去好像是网关错误，其实不是。实际上，<font color="red">502状态码通常是由网关Nginx与上游服务之间的TCP连接异常导致的，或者是上游服务直接返回了502状态码</font>
# WriteTimeout 网关与tcp
如果是网关Nginx与上游服务之间的TCP连接异常导致的502状态码，Nginx一定会记录错误日志 (以nginx实现的网关为例)
```go
[error] upstream prematurely closed connection while reading response header from upstream ...
```
- 该502状态码产生的原因是，当网关等待从上游服务读取响应头时，上游服务过早地关闭了连接。(Go服务在检测到请求超时后，直接关闭了TCP连接)
  

## WriteTimeout超时功能的实现逻辑
- 请求超时时间为3s，为什么5s后Go服务才关闭连接呢？

当Go服务接收到客户端请求时，首先根据WriteTimeout添加定时器，<font color="red">该定时器的作用是超时后设置与客户端的连接为已超时（注意只是设置一个标识位）</font>，所以即使请求处理时间已超过WriteTimeout，Go服务依然还在默默地处理请求。<font color="red">当Go服务处理完该HTTP请求准备向客户端返回数据时，检测到与客户端的连接为已超时</font>，于是便关闭了与客户端的TCP连接，从而导致网关返回了502状态码。

![alt text](image1.png)
# panic 网关与上游服务
Go服务并没有退出（panic异常可能会导致Go服务退出），说明一定有函数recover捕获了异常，并输出了协程调用栈(控制台输出了捕捉的panic日志)，
- 可是既然都捕获panic异常了，为什么网关返回的还是502呢？
查看nginx日志 (以nginx实现的网关为例)
```go
[error] upstream prematurely closed connection while reading response header from upstream
```
网关Nginx在等待上游Go服务返回HTTP响应时，上游Go服务过早地关闭了TCP连接。

```go
func (c *conn) serve(ctx context.Context) {
    defer func() {
        if err := recover(); err != nil && err != ErrAbortHandler {
            ……
            c.server.logf("http: panic serving %v: %v\n%s", c.remoteAddr, err, buf)
            c.close()
        }
    }()
}
```
- 针对TCP连接，Go语言都会创建新的协程来处理从该连接接收到的HTTP请求，并且使用了函数recover来捕获panic异常

常见的panic异常有一些了解，比如空指针异常、数组/切片索引越界、操作未初始化的散列表、并发操作散列表、类型断言等

# 长连接为什么会导致502

## 什么是长链接
网关Nginx在代理HTTP请求时默认使用的是短连接，想要使用长连接需要修改网关Nginx的配置 (keepalive用于设置空闲长连接的数目)
```go
// 建立TCP连接
17:30:22 IP x.x.x.x.64137 > x.x.x.x.8080: Flags [S], length 0
17:30:22 IP x.x.x.x.8080 > x.x.x.x.64137: Flags [S.], length 0
17:30:22 IP x.x.x.x.64137 > x.x.x.x.8080: Flags [.], length 0
// 第一个HTTP请求
17:30:22 IP x.x.x.x.64137 > x.x.x.x.8080: Flags [P.], length 77: HTTP: GET /ping HTTP/1.1
17:30:22 IP x.x.x.x.8080 > x.x.x.x.64137: Flags [.], length 0
17:30:22 IP x.x.x.x.8080 > x.x.x.x.64137: Flags [P.], length 138: HTTP: HTTP/1.1 200 OK
// 第二个HTTP请求
17:30:25 IP x.x.x.x.64137 > x.x.x.x.8080: Flags [P.], length 77: HTTP: GET /ping HTTP/1.1
17:30:25 IP x.x.x.x.8080 > x.x.x.x.64137: Flags [.], length 0
17:30:25 IP x.x.x.x.8080 > x.x.x.x.64137: Flags [P.], length 138: HTTP: HTTP/1.1 200 OK
```
第一次发起HTTP请求时，同样需要建立TCP连接。不同的是，当客户端收到第一个HTTP请求的响应时，没有关闭TCP连接。这样一来，当客户端第二次发起HTTP请求时，就能够复用该TCP连接，从而提高传输效率。

## http服务维护长链接

维护长连接是需要消耗系统资源的。所以我们通常会关闭长时间不使用的长连接（称之为空闲长连接）。

- keepalive_timeout 60s, 设置空闲长链接超时时间,长连接处于空闲状态的时间超过60秒之后，我们应该关闭该长连接.<font color="red">在Go语言中，我们可以使用IdleTimeout来设置空闲长连接的超时时间</font>

## Go服务设置的IdleTimeout小与网关的keepalive_timeout

Go服务设置的IdleTimeout小于网关Nginx设置的keepalive_timeout，会出现什么情况呢？Go服务有可能先于网关Nginx关闭这个长连接

![alt text](image2.png)
- Nginx是作为客户端向Go服务发起HTTP请求的

Go服务关闭长连接的同时，网关Nginx恰好又发起了一个HTTP请求呢？由于Go服务已经关闭了长连接，所以Go服务所在节点会直接返回一个RST包（参考TCP协议，RST用于重置连接）。对于网关Nginx来说，这就意味着<font color="red">转发HTTP请求出错了（错误信息是"Connection reset by peer"）。于是，网关Nginx就会向客户端返回一个502状态码。</font>

## 长链接服务重启

使用长连接时，服务重启也有可能会引起502。毕竟**老的Go服务在退出时，首先会关闭监听的套接字以及空闲长连接，然后在处理完当前所有的HTTP请求（同时关闭对应的TCP连接）之后才会退出** 当老的Go服务在关闭空闲长连接时，网关Nginx可能恰好又发起了一个HTTP请求，这时就有可能出现 502状态码。