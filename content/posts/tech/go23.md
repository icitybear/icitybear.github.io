---
title: "go设计模式-Option思想(选项模式)" #标题
date: 2023-08-10T10:21:24+08:00 #创建时间
lastmod: 2023-08-10T10:21:24+08:00 #更新时间
author: ["citybear"] #作者
categories: # 没有分类界面可以不填写
- tech
tags: # 标签
- go设计模式
keywords: 
- 
description: "" #描述 每个文章内容前面的展示描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true #是否展示评论 有自带的扩展成twikoo
showToc: true # 显示目录 文章侧边栏toc目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
    image: "" #图片路径：posts/tech/文章1/picture.png
    caption: "" #图片底部描述
    alt: ""
    relative: false

# reward: true # 打赏
mermaid: true #自己加的是否开启mermaid
---

**[b站视频option-类型定义与类型别名](https://www.bilibili.com/video/BV1Mg4y1R7Jf)**
{{< innerlink src="posts/tech/go10.md" >}}  

**[b站视频option-2种场景](https://www.bilibili.com/video/BV16G411C7Cb)**

# option构造

## 生产option 使用闭包 的函数，进行构造用
``` go
type Demo struct{...}

type optOption func(*Demo) // 修改主类值相关的函数

func NewXXX (opts ...optOption) *Demo {
    // 遍历调用
    d := new(Demo)
    ...
    for _, opt := range opts {
        opt(d)
    }
    ...
    return d
}

// 用来生产optOption的函数，回调里修改主类值对应的字段
func WithXXX(修改的字段参数值val) optOption {
    // 对应的匿名函数去修改属性
    return func(u *Demo){
        u.xxx = val
    }
}

// optOption的函数形式 对比下优缺点 适合接口那种适配器用法，构造的话需要一个闭包
func abc(u *Demo) {
    u.xxx = "存在参数要设置只能写死问题"  //定义实现接口的方式下 缺点：直接暴露成员了
}

// 调用 配置项=>更改值本身的方法(可选参数)
NewXXX(WithXXX(),WithXXX2(),)

```
- 不可能每次需要修改 都传一次变量，直接用一个函数 封装起来作为返回值。 闭包起来
- <font color="red">使用闭包，成员不会对外暴露, 构造器的可选参数可动态配置</font>

![Alt text](image.png)

## option为interface, 接口里定义方法去修改类的参数
- 比第一种复杂，但是接口可以包含多个函数，且可以使用适配器转换
``` go
// 主类
type Demo struct{...}

func NewDemo (opts ...optOption) *Demo {
    // 遍历调用
    d := new(Demo)
    for _, opt := range opts {
        opt.Apply(d)
    }

    return d
}

// target
type optOption interface {
    Apply(*Demo) // 要指针才能修改  修改主类值 只是从func类型改为了interface 调用的地方也是响应的方法
}

// 定义新的结构体去实现接口 （正常模式）
type Custom Struct {...}
func (c *Custom) Apply(d *Demo) {
    d.xxx = c.xxx // 构造c时候的传参
}
func NewCustom(xxx) {
    // 进行赋值
}

// 函数类型作为接口 相当于适配器（非正常模式，适用单个功能的适配器）
// 定义函数实直接实现接口 适配器模式
type Adapter func(*Demo)
// 注意这里不使用 *Adapter 函数类型不能再用指针了 增强函数用法（装饰器, 适配器）
func (f Adapter) Apply (d *Demo) {
    f(d)
}

// 匿名函数作为闭包 注入接口
xxxOpt := func(d *Demo) {
    d.xxx = 12
}

// client调用方 
NewDemo(NewCustom(aa,11), Adapter(xxxOpt))
```

![Alt text](image2.png)
![Alt text](image3.png)

``` go
const KUAISHOU_API_URL string = "https://ad.e.kuaishou.com/rest"

// 主类
type TQMarketingKuaishou struct {
	TQMarketingApi // 实现统一接口约束
	ctx            context.Context
    // 成员不对外暴露
	advertiser     *models.KsAdvertiserList
	accessToken    string
	token          string
	// apiVersion
}

type KSMarketingOption func(*TQMarketingKuaishou)

func newTQMarketingKuaishou(opts ...KSMarketingOption) *TQMarketingKuaishou {
	obj := TQMarketingKuaishou{}

	for _, o := range opts {
		o(&obj)
	}
	return &obj
}

func WithContextKs(ctx context.Context) KSMarketingOption {
	return func(o *TQMarketingKuaishou) {
		o.ctx = ctx
	}
}

func WithAccessTokenKs() KSMarketingOption {
	return func(o *TQMarketingKuaishou) {
		advertiserRepo := data.NewKsAdvertiserListRepo()
		o.accessToken = advertiserRepo.GetToken(o.ctx)
	}
}


// 后续相应SyncMaterial GetMaterialDetail
``` 

``` go
// 调用的地方
type TQMarketingApi interface {
	SyncMaterial(advertiserId string, fileType UploadFileType, filePath string, fileName string) (string, error)
	GetMaterialDetail(advertiserId string, materialId int64) (string, error)
	// 建议后续都实现设置接口版本的方法
}

func NewTqMarketingService(ctx context.Context, mediaCode string) TQMarketingApi {
	var api TQMarketingApi
	switch mediaCode {
	case constant.MediaCodeToutiao:
		api = newTQMarketingToutiao(ctx)
	case constant.MediaCodeKuaishou:
		api = newTQMarketingKuaishou(WithContextKs(ctx), WithAccessTokenKs())
	case constant.MediaCodeQQ:
		api = newTQMarketingQq(WithContextQq(ctx), WithAccessTokenQq(), WithVersionQq(QQ_API_VERSION_1_3))
	default:
		api = newTQMarketingToutiao(ctx)
	}

	return api
}

```

## 使用option的时候，还有链式调用的,修改成员属性，不放构造里
## 比如httpserver那些库使用option，因为场景很多，有些需要timeout长一点，有些需要bind多个地址

# 作为一种查询过滤器集合

# <font color="red">选项模式的演进（options）</font>
Go 中的选项模式。在参数比较多，且大部分有默认值的情况下，我们可以在函数最后添加一个可变的选项参数，通过传入选项来改变函数的行为，不传入的选项就使用默认值
**[友好 API 的功能选项](https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis)**

0. 需要更改 API 以纳入所有这些功能请求(需求扩张)， 本来就一个公共api
1. 创建一组函数，而不是尝试提供必须满足每种排列的单个函数
   1. 当调用者需要安全服务器时，他们可以调用 TLS 变体。当他们需要建立空闲连接的最大持续时间时，他们可以使用超时的变体。
   2. <font color="red">提供每一种可能的排列很快就会变得难以承受(继续优化)</font>
2. 使用配置结构, 配置结构可以随着新选项的添加而随着时间的推移而增长，而用于创建服务器本身的公共 API 保持不变。
   1. <font color="red">默认值方面存在问题，特别是当零值具有很好理解的含义时 (并不完美, 继续优化)</font> , 例如，配置结构中，当Port未提供时，NewServer将返回一个*Server用于侦听端口 8080。(默认的)
   2. 大多数时候，API 的用户会期望使用其默认行为。即使他们不打算更改任何配置参数，这些调用者仍然需要为第二个参数传递一些内容。<font color="red">为什么 API 的用户需要构造一个空值，只是为了满足函数的配置结构</font>
      - 空值问题的常见解决方案:是传递指向该值的指针，从而使调用者能够使用 nil 而不是构造空值。如果该值在传递给函数后发生变化，会发生什么NewServer? 
  	![alt text](image4.png)
   3. <font color="red">作为 Go 程序员，应该努力确保 nil 永远不会成为需要传递给任何公共函数的参数</font>，解决方案：更改该NewServer函数以<font color="red">接受可变数量的参数。</font>NewServer现在只接受Config值，而不接受指向配置值的指针，删除nil可能的参数，并确保调用者无法保留对服务器内部配置的引用。
	![alt text](image5.png)
   4. (挑刺的话)仍然存在一些问题。最多提供一个Config值, 但由于函数签名是可变的，因此必须编写实现来应对调用者传递多个可能相互矛盾的配置结构。
3. 有没有办法在需要时使用可变参数函数签名并提高配置参数的表达能力
   1. 主要区别在于，服务器的定制<font color="red">不是使用存储在结构中的配置参数来执行的，而是使用对值本身进行操作的函数Server来执行的, </font>传递给对值进行操作的函数
   2. <font color="red">NewServer 公共api，接收对值进行操作的函数Server(作为可变数量的参数)</font>
      - 该timeout函数只是更改传递给它的timeout任何*Server值的字段。
      - 功能tls稍微复杂一点。它接受一个*Server值并将原始listener值包装在 a 内tls.Listener，从而将其转换为安全侦听器。
![alt text](image6.png)
![alt text](image7.png)
   3. **<font color="red">合理的默认值,高度可配置,可以随着时间的推移而增长，对于新人来说是安全的，不需要 nil 或空值</font>**
   
- 思考过程
  - 这可以变得更简单吗？
  - 这个参数有必要吗？
  - 这个函数的签名是否方便安全使用？
  - API 是否包含陷阱或令人困惑的误导？