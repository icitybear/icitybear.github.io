---
title: "Go包-sync.WaitGroup工作组和mapReduce" #标题
date: 2025-08-15T10:59:55+08:00 #创建时间
lastmod: 2025-08-15T10:59:55+08:00 #更新时间
author: ["citybear"] #作者
categories: # 没有分类界面可以不填写
- tech
tags: # 标签
- go包
- go源码
- go并发编程
keywords: 
- 
description: "" #描述 每个文章内容前面的展示描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true #是否展示评论 有自带的扩展成twikoo
showToc: true # 显示目录 文章侧边栏toc目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
    image: "" #图片路径：posts/tech/文章1/picture.png
    caption: "" #图片底部描述
    alt: ""
    relative: false

# reward: true # 打赏
mermaid: true #自己加的是否开启mermaid
---


- <font color="red">[b站视频-Go语言单机MapReduce实现方案sync.WaitGroup](https://b23.tv/ByjEJEx)</font>


 Golang GMP 时，我和大家讨论了 goroutine 的调度方式分为主动让渡和被动调度. 其中触发被动调度的常见方式包括通道 channel 和单机锁 sync.Mutex. 在此之上，今天再补充另一种可能触发 goroutine 被动调度的工具——并发等待组 sync.WaitGroup

# channel实现初始版本 
 ![alt text](image2.png)
- 不同 goroutine 之间的通信协作，我个人首先想到的就是使用 channel 进行实
``` go 
func Test_waitGroup(t *testing.T) {
    // 并发任务数
    tasksNum := 10

    ch := make(chan struct{}, tasksNum)
    for i := 0; i < tasksNum; i++ {
        go func() {
            defer func() {
                ch <- struct{}{}
            }()
            // working
            <-time.After(time.Second)
        }()
    }

    // 等待 10 个 goroutine 完成任务
    for i := 0; i < tasksNum; i++ {
        <-ch
    }

    // do next
    // ...
}
```
- 缺点：
  1. 主 goroutine 需要在一开始就明确启动的子 goroutine 数量，从而建立好对应容量的 channel，以及设定执行 for 循环接收信号量的次数. 这样的设定不够灵活，因为在场景题中 leader 手下的 follower 数量可能会有实时增减
  2. channel 中的信号量消费是一次性的. 因此倘若存在多名 leader 想要同时使用聚合模式，这种场景是无法支持的. 除非创建多个 channel，分别给每名 leader 分配一个独立的 channel，每个 follower 完成工作后需要同时往多个 channel 中传递信号量

# sync.WaitGroup
- cas计数器+协程调度实现动态的工作数量, 多个leader等待同一个wg
![alt text](image3.png)
![alt text](image4.png)

# 使用
- 并发安全的(操作串行执行),计数器 cas+协程调度
- <font color="red">有效地管理并发任务的执行顺序和同步，确保所有的goroutine都执行完成后再进行下一步操作。</font>
  1. Add：WaitGroup 类型有一个计数器，默认值是 0，我们可以通过 Add 方法来增加这个计数器的值，标记需要等待的子协程数量
  2. Done：当某个子协程执行完毕后，可以通过 Done 方法标记已完成，该方法会将所属 WaitGroup 类型实例计数器值减 1，**通常可以通过 defer 语句来调用它**
  3. Wait：Wait 方法的作用是<font color="red">阻塞当前协程</font>，直到对应 WaitGroup 类型实例的计数器值归零，如果在该方法被调用的时候，对应计数器的值已经是 0，那么它将不会做任何事情。 可以多领导使用wg同时阻塞 该结构体不允许值赋值

- <font color="red">运行时才能知道计数器的数目</font>，这种情况下，sync.WaitGroup 会更加方便，我们可以这样在循环体内部动态增加计数器，而不是一开始就指定总数
  - <font color="red">需要确保 Add 方法增加的数量和 Done 方法减少的数量是一致</font>
  - 所有协程执行完毕计数器是正数，会导致协程阻塞, fatal error: all goroutines are asleep - deadlock!
  - Add 调用次数小于 Done 调用次数，会导致计数器出现负数, panic: sync: negative WaitGroup counter
  
## **使用注意点**
1. Add放在调用子Goroutine外(前面)，Done放在Goroutine中，建议用defer保证调用。为啥先Add?
    - 由于子 goroutine 是异步启动的，所以有可能出现 Wait 方法先于 Add 方法执行，此时由于计数器值为 0，Wait 方法会被直接放行，导致产生预期之外的执行流程
    - 遵循一个“轮次”的概念. 轮次的结束是在 WaitGroup 计数器被置为 0 的时刻，此时因 Wait 操作而陷入阻塞的一系列 goroutine 会得到一次被唤醒的机会. 在轮次终止的时候，如果再并发地执行 Add 操作，则会引发 panic
2. 每次通过 wg.Add() 函数设置当前批次启动的子协程数量， wg.Done() 函数最好和 wg.Add() 函数配对使用，否则可能会引起 panic。
3. 尽量不在wg.Wait() 后继续使用通一个wg

``` go
package main
​
import (
    "fmt"
    "sync"
    "time"
)
​
func addV2(a, b int, wg *sync.WaitGroup) {
    defer wg.Done() // 子协程执行完毕后将计数器-1
    c := a + b
    fmt.Printf("%d + %d = %d\n", a, b, c)
}

func addV3(a, b int, doneFunc func()) {
    defer func() {
        doneFunc() // 子协程执行完毕后将计数器-1
    }()
    c := a + b
    fmt.Printf("%d + %d = %d\n", a, b, c)
}
​
func main() {
    start := time.Now()
    wg := sync.WaitGroup{} // var wg sync.WaitGroup
     //wg.Add(10) // 初始化计数器数目为10  无法保证子协程的顺序
    for i := 0; i < 10; i++ {
        wg.Add(1) // 运行时才能知道计数器的数目, 循环体内动态增加计数器，每次+1 无法保证子协程的顺序 为什么先Add
        // go addV2(1, i, &wg)
        go addV3(1, i, wg.Done) // wg.Done本质就是一个函数 放到闭包里执行
    }
​
    wg.Wait() // 等待子协程全部执行完毕退出
    end := time.Now()
    consume := end.Sub(start).Seconds()
    fmt.Println("程序执行耗时(s)：", consume)
}
// 顺序是无序的
=== RUN   TestGroutine3
1 + 9 = 10
1 + 2 = 3
1 + 3 = 4
1 + 4 = 5
1 + 5 = 6
1 + 6 = 7
1 + 7 = 8
1 + 8 = 9
1 + 1 = 2
1 + 0 = 1
程序执行耗时(s): 0.000219791
```

# WaitGroup + channel 完成数据聚合 (mapReduce模式)
-  leader 光是知道 follower 已经完成工作这一事件还不够，**还需要切实接收到来自 follower 传递的“工作成果”**. 这部分内容就涉及到的 goroutine 之间的数据传递

## 1.0版本
![alt text](image5.png)
``` go
func Test_waitGroup(t *testing.T) {
    tasksNum := 10
    dataCh := make(chan interface{}) // 用于数据传输的 channel 无缓冲类型，因为后续会开启一个持续接收数据的读协程，写协程不会出现阻塞的情况
    resp := make([]interface{}, 0, tasksNum) // 承载聚合后的数据结果 非并发安全的数据结构 在往 slice 中写数据时需要保证是串行化进行的
    // 启动读 goroutine
    go func() {
        //  tag: for range 的方式遍历 channel，只有在 channel 被关闭且内部数据被读完的情况下，遍历才会终止
        for data := range dataCh {
            resp = append(resp, data)
        }
    }()

    // 保证获取到所有数据后，通过 channel 传递到读协程手中
    var wg sync.WaitGroup
    for i := 0; i < tasksNum; i++ {
        wg.Add(1)
        // 启动多个子 goroutine，模拟任务的进行
        go func(ch chan<- interface{}) {
            defer wg.Done()
            ch <- time.Now().UnixNano()
        }(dataCh)
    }
    // 确保所有取数据的协程都完成了工作，才关闭 ch
    wg.Wait()

    // tag: 缺点:此时 dataCh 虽然关闭了，但是由于异步的不确定性，读 goroutine 可能还没来得及将所有数据都聚合到 resp slice 当中
    close(dataCh)

    // 存在数据缺失
    t.Logf("resp: %+v", resp)
}
```

## 优化版v1 多stopCh
-  goroutine 可能在读 goroutine 完成数据聚合前，就已经取用了 resp slice. 那么我们就**额外启用一个用于标识读 goroutine 是否执行结束的 channel：stopCh**
![alt text](image6.png)
``` go
func Test_waitGroup(t *testing.T) {
    tasksNum := 10

    dataCh := make(chan interface{})
    resp := make([]interface{}, 0, tasksNum)
    stopCh := make(chan struct{}, 1)

    go func() {
        for data := range dataCh {
            resp = append(resp, data)
        }
        stopCh <- struct{}{} // tag: 通知主 goroutinue 数据都读取聚合完毕了
    }()

    var wg sync.WaitGroup
    for i := 0; i < tasksNum; i++ {
        wg.Add(1)
        go func(ch chan<- interface{}) {
            defer wg.Done()
            ch <- time.Now().UnixNano()
        }(dataCh)
    }
    // 确保所有取数据的协程都完成了工作，才关闭 ch
    wg.Wait()
    close(dataCh)

    // tag:确保读协程处理完成
    <-stopCh

    t.Logf("resp: %+v", resp)
}
```

## 优化版v2 go协程包一层 (更优雅)
- 异步启动一个总览写流程的写 goroutine，在这个写 goroutine 中，基于 WaitGroup 使用模式，让写 goroutine 中进一步启动的子 goroutine 在完成工作后，将数据发送到 dataCh 当中
![alt text](image7.png)
- 因为由于版本1的 dataCh 虽然关闭了，但是由于异步的不确定性，异步读 goroutine 可能还没来得及将所有数据都聚合到 resp slice 当中。 读的改为放在主goroutine
``` go
func Test_waitGroup(t *testing.T) {
    tasksNum := 10
    dataCh := make(chan interface{})
    // tag: 启动写 goroutine总，推进并发获取数据进程，
    go func() {
        var wg sync.WaitGroup
        for i := 0; i < tasksNum; i++ {
            wg.Add(1)
            go func(ch chan<- interface{}) {
                defer wg.Done()
                ch <- time.Now().UnixNano() // 将获取到的数据聚合到 channel 中
            }(dataCh)
        }
        // 确保所有取数据的协程都完成了工作，才关闭 dataCh
        wg.Wait() // 本质就是子异步里进行close，主goroutinue进行同步读
        close(dataCh) 
    }()

    resp := make([]interface{}, 0, tasksNum)
    // tag: 主协程作为读协程，持续读取数据，直到所有写协程完成任务，chan 被关闭后才会往下
    for data := range dataCh {
        resp = append(resp, data)
    }

    // tag: 此时不存在丢数据
    t.Logf("resp: %+v", resp)
}

func Test_waitGroup(t *testing.T) {
    tasksNum := 10
    dataCh := make(chan interface{})

    var wg sync.WaitGroup
    for i := 0; i < tasksNum; i++ {
        wg.Add(1)
        go func(ch chan<- interface{}) {
            defer wg.Done()
            ch <- time.Now().UnixNano() // 将获取到的数据聚合到 channel 中
        }(dataCh)
    }

    go func() {
        // 确保所有取数据的协程都完成了工作，才关闭 dataCh
        wg.Wait() // 本质就是子异步里进行close，主goroutinue进行同步读阻塞
        close(dataCh) 
    }()

    resp := make([]interface{}, 0, tasksNum)
    // tag: 主协程作为读协程，持续读取数据，直到所有写协程完成任务，chan 被关闭后才会往下
    for data := range dataCh {
        resp = append(resp, data)
    }

    // tag: 此时不存在丢数据
    t.Logf("resp: %+v", resp)
}
```

# 源码解析
![alt text](image8.png)
![alt text](image9.png)
![alt text](image10.png)
``` go
type WaitGroup struct {
    // 防止值拷贝标记
    noCopy noCopy

    // 64 个 bit 组成的状态值，
    // 高 32 位标识了差值 goroutine 执行了 WaitGroup.Add和WaitGroup.Done；
    // 低 32 位表示了当前多少 goroutine 执行了 WaitGroup.Wait 操作陷入阻塞中了
    state1 uint64
    // 用于将 goroutine 阻塞和唤醒的信号量
    state2 uint32
}

func (wg *WaitGroup) state() (statep *uint64, semap *uint32) {
    // ...
    return &wg.state1, &wg.state2
    // ...
}

func (wg *WaitGroup) Done() {
    wg.Add(-1)
}

// 等待组计数器加 1
func (wg *WaitGroup) Add(delta int) {
    // 获取等待组的状态标识值，statep 指向 state1 的地址，semap 是用于阻塞挂起 goroutine 队列的标记值
    statep, semap := wg.state()
    // ...
    // state1 高 32 位加 1，标识执行任务数量加 1 
    state := atomic.AddUint64(statep, uint64(delta)<<32)
    // 取的是 state 高 32 位的值，代表有多少个 goroutine 在执行任务
    v := int32(state >> 32)
    // w 取的是 state 低 32 位的值，代表有多少个 goroutine 执行了 WaitGroup.Wait 在阻塞等待
    w := uint32(state)
    // ...
    //  WaitGroup 计数器出现负值，直接 panic（ Done 不应该多于 Add ）
    if v < 0 {
        panic("sync: negative WaitGroup counter")
    }
    // tag: 异常情况 倘若存在 goroutine 在阻塞等待 WaitGroup.Wait，但是在执行 WaitGroup.Add 前，执行任务计数器的值为 0
    if w != 0 && delta > 0 && v == int32(delta) {
        panic("sync: WaitGroup misuse: Add called concurrently with Wait")
    }
    // tag: 倘若当前没有 goroutine 在 Wait，或者任务执行计数器仍大于 0，则直接返回
    // 计数器出现负值，直接 panic（ Done 不应该多于 Add ）
    if v > 0 || w == 0 {
        return
    }
    // tag: 接下来是要唤醒
    // 本次 Add 操作后， WaitGroup 计数器被清零了，则接下来需要依次把因 Wait 操作而陷入阻塞的 goroutine 唤醒. 在这期间，不允许再并发执行 Add 操作，否则会 panic
    if *statep != state {
        panic("sync: WaitGroup misuse: Add called concurrently with Wait")
    }
    // tag: 将 state1 计数器置为 0，然后依次唤醒执行过 Wait 的 waiters
    *statep = 0
    for ; w != 0; w-- {
        //  runtime_Semrelease 方法，底层会执行 goready 操作，属于 goroutine 的被动调度模式
        runtime_Semrelease(semap, false, 0)
    }
}

func (wg *WaitGroup) Wait() {
    // 获取 WaitGroup 状态字段的地址
    statep, semap := wg.state()
    // ...
    for {
        state := atomic.LoadUint64(statep)
        v := int32(state >> 32)
        w := uint32(state)
        // 倘若当前需要等待完成任务的计数器值为 0，则无需 wait 直接返回
        if v == 0 {
            // ...
            return
        }
        // tag: wait 阻塞等待 waitGroup 的计数器加一，然后陷入阻塞
        // tag: 如果cas失败 就继续for下一次循环
        if atomic.CompareAndSwapUint64(statep, state, state+1) {
            // ...
            runtime_Semacquire(semap)  // tag: 此时挂起阻塞等待唤醒
            // tag: 从阻塞中回复，倘若前一轮 wait 操作还没结束，waitGroup 又被使用了，则会 panic
            // 在被唤醒的 goroutine 返回前，WaitGroup 不能被并发执行 Add 操作，否则会陷入 panic
            if *statep != 0 {
                panic("sync: WaitGroup is reused before previous Wait has returned")
            }
            // ...
            return
        }
    }
}
```